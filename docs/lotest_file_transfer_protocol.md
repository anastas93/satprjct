# Протокол передачи файлов Lotest поверх SX1262

Документ описывает реализованный в проекте `testing/fimrare` стек обмена файлами объёмом до 4 КиБ с фиксированным размером пакета 8 байт и полезной нагрузкой DATA-пакета 5 байт. Формат соответствует внутреннему протоколу Lotest File Transfer, применяемому веб-интерфейсом и прошивкой ESP32.

## 1. Общие положения

* **Размер пакета:** 8 байт (implicit header SX1262).
* **Полезная нагрузка DATA:** 5 байт (`B3..B7`).
* **Фрагментация:** сообщение дробится на блоки по 5 байт, последний блок может содержать 1–5 байт.
* **Нумерация:** поле `SEQ` в диапазоне `0..255`, инкремент по модулю 256.
* **Контроль целостности:** CRC-16/CCITT-FALSE (poly `0x1021`, init `0xFFFF`, xorout `0x0000`).
* **Сессия:** идентификатор `SID` (1 байт), START → DATA → FIN. ACK/ABORT распознаются, но логика ARQ пока в разработке.

## 2. Поля пакета

Байт `B0` содержит скомпонованные поля:

* `ver` — 2 старших бита (текущая версия = 0).
* `type` — 3 бита (`0=DATA`, `1=START`, `2=ACK`, `3=FIN`, `4=ABORT`).
* `flags/len` — 3 бита: для DATA хранит `data_len-1` (0..4 → длина 1..5 байт), для других типов трактуется как флаги.

`B1` — идентификатор сессии `SID`.

### START (`type=1`)

```
B0: [ver|type=1|flags=0]
B1: SID
B2..B3: total_size_bytes (u16, 0..4096)
B4..B5: file_crc16 (u16, CRC-16/CCITT-FALSE)
B6: file_id_hash8 (произвольная 8-битная метка файла)
B7: reserved=0
```

### DATA (`type=0`)

```
B0: [ver|type=0|len=(data_len-1)]
B1: SID
B2: SEQ (u8, modulo 256)
B3..B7: данные (1..5 байт, нулевые хвосты не используются)
```

### ACK (`type=2`)

```
B0: [ver|type=2|flags=0]
B1: SID
B2: NXT (следующий ожидаемый SEQ)
B3..B4: BITMAP16 (бит0=NXT-1, ... бит15=NXT-16; 1=получено)
B5: wnd (рекомендуемый размер окна, по умолчанию 16)
B6: reserved=0
B7: reserved=0
```

### FIN (`type=3`)

```
B0: [ver|type=3|flags=0]
B1: SID
B2: last_len (1..5; допускается 0 для пустых файлов)
B3..B4: file_crc16 (u16)
B5: last_seq (SEQ последнего DATA)
B6..B7: reserved=0
```

### ABORT (`type=4`)

```
B0: [ver|type=4|flags=reason(0..7)]
B1: SID
B2..B7: reserved=0
```

## 3. Процедура обмена

1. **START:** передаётся размер файла, контрольная сумма и идентификатор.
2. **ACK:** приёмник отвечает `ACK` с `NXT=0` и `wnd=16` (необязательно в текущей реализации, но поддерживается для логирования).
3. **DATA:** отправитель передаёт блоки по 5 байт в пределах скользящего окна (по умолчанию 16). Между пакетами выдерживается пауза 50 мс.
4. **ACK:** приёмник может отправлять подтверждения по таймеру, по заполнению окна или при обнаружении «дыр».
5. **FIN:** завершает сессию, содержит длину последнего блока и финальную CRC.
6. **Проверка:** приёмник сравнивает полученную CRC и размер с ожидаемыми. При успехе — `ACK` с `BITMAP16=0xFFFF`, при ошибке — `ABORT`.

## 4. Параметры тайминга

* Окно (`wnd`) — 16 (можно снижать до 8 при узком канале).
* `Tack` — 2–3 × RTT или фиксированные 300 мс.
* `Trtx` — 4 × `Tack`.
* `START`/`FIN` повторяются до 5 раз при отсутствии ответа.

## 5. Поведение при потере пакетов

* Дубликаты DATA внутри окна игнорируются.
* Пакеты вне окна отбрасываются.
* При переполнении буфера приёмник уменьшает `wnd` в `ACK`.

## 6. Реализация в Lotest

Ключевые функции находятся в `testing/fimrare/src/main.cpp`:

* `sendPayload()` — фрагментация сообщений, расчёт CRC/хэша и запуск передачи.
* `buildTransferPackets()` + `buildStartPacket()` + `buildDataPacket()` + `buildFinPacket()` — подготовка пакетов START/DATA/FIN.
* `transmitPacket()` — отправка 8-байтового блока через RadioLib.
* `processIncomingPacket()` — обработка принятого пакета, сборка данных, проверка CRC.
* `crc16CcittFalse()` — вычисление контрольной суммы.
* `hashFileId()` — формирование 8-битного идентификатора файла.
* `describePacket()`/`describePacketType()` — человекочитаемые описания пакетов для веб-журнала.

## 7. Незаполненные части

* Реализация оконного ARQ с повторными отправками DATA по битовой карте.
* Генерация и отправка `ACK` на стороне приёмника.
* Переход на асинхронную обработку таймеров `Tack`/`Trtx`.

Документ служит ориентиром при дальнейшей доработке протокола и проверке совместимости между прошивкой и серверными утилитами.
