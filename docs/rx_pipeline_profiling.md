# Диагностика пути принятого пакета в `RxModule`

Документ фиксирует полный цикл прохождения кадра в `RxModule` — от получения массива байтов до
выдачи собранного сообщения наружу. Описаны ключевые этапы, типовые точки отказов и способы
контроля задержек с помощью встроенного профилирования.

## Быстрый обзор этапов

1. **Очистка временных структур.** Перед обработкой выполняется `cleanupPendingConv()` и
   `cleanupPendingSplits()`. Если в профиле наблюдается длительное общее время при минимальных
   этапах декодирования, стоит проверить обрастание `pending_conv_`/`pending_split_`.
2. **Дескремблирование (`descramble`).** Снимает псевдослучайную маску. Ошибка на этом этапе не
   фиксируется отдельно, но длительное время при коротких кадрах может указывать на проблемы с
   буферизацией или перепаковкой в пользовательском коде.
3. **Декодирование заголовка (`header`).** Два смещённых чтения `FrameHeader`. Если оба провалились,
   профиль отмечает `drop_stage = "заголовок повреждён"` и одновременно отправляет сырой кадр в
   буфер/колбэк. Это позволяет увидеть «плавающие» ошибки фронтенда либо сильные искажения.
4. **Удаление пилотов и проверка CRC (`payload_extract`).** Несовпадение длины либо CRC фиксируется
   соответствующими строками `drop_stage`.
5. **Сборка фрагментов.** Контроль `msg_id`, `frag_cnt` и `frag_idx` защищает от перепутанных
   последовательностей. При внезапных «прыжках» индекса запись `нарушена последовательность
   фрагментов` в профиле покажет источник сброса.
6. **Буферизация свёрточных блоков.** Для `FLAG_CONV_ENCODED` пакетов профилирование различает:
   - `ожидание продолжения свёрточного блока` — пришла неполная часть, кадр не готов;
   - `переполнение свёрточного блока` или `сбой длины свёрточного блока` — ошибки структуры.
7. **Декодирование (`decode`).** Время показывает, сколько заняли деинтерливинг и кодеки. Если поле
   `decode` значительно больше остальных, стоит проверить частоту очистки `pending_conv_` и скорость
   реализации RS/Viterbi. При провале поле `dropped = true`, а `drop_stage = "сбой декодирования"`.
8. **Дешифрование (`decrypt`).** При активном шифровании `drop_stage = "ошибка AES-CCM"` позволяет
   отличить неверный ключ от прочих проблем. Для открытого режима поле `decrypted = false`.
9. **Анализ префикса Split (`assemble`).** Отмечает время обработки `[TAG|n/m]`. Если часть оказалась
   промежуточной (`deliver = false`), профиль содержит `drop_stage = "ожидание остальных частей split"`.
10. **Выдача результата (`deliver`).** Показывает суммарное время записи в `ReceivedBuffer` (если
    задействован) и вызова пользовательского колбэка.

## Поля `ProfilingSnapshot`

| Поле                    | Назначение                                                                 |
|-------------------------|----------------------------------------------------------------------------|
| `valid`                 | Есть ли свежие данные (активируется после любого вызова `onReceive`).      |
| `dropped`               | Кадр не был собран/передан (см. `drop_stage`).                             |
| `conv`                  | Было ли задействовано свёрточное кодирование.                              |
| `decrypted`             | Выполнялся ли AES-CCM.                                                     |
| `raw_len`               | Исходная длина принятого кадра.                                            |
| `decoded_len`           | Длина после обратного кодирования (до отделения тега).                     |
| `drop_stage`            | Короткое описание причины остановки.                                       |
| `total`                 | Полное время прохождения по цепочке.                                       |
| `descramble`–`deliver`  | Длительности отдельных этапов (см. список выше).                           |

> Все длительности измеряются в микросекундах (`std::chrono::microseconds`). Пустые этапы (например,
> дешифрование при открытом кадре) будут равны `0`.

## Использование профилирования

```cpp
RxModule rx;
rx.enableProfiling(true);
...
rx.onReceive(data, len);
auto snapshot = rx.lastProfiling();
if (snapshot.dropped) {
  Serial.printf("Кадр отклонён на этапе %s\n", snapshot.drop_stage.c_str());
}
```

Рекомендуется логировать `total`, `decode` и `deliver` для мониторинга скорости. Если `total` растёт
при стабильных длинах кадра, стоит проверить заполнение очереди `ReceivedBuffer` либо длительность
пользовательского колбэка.

## Типовые сигналы о проблемах

- **Систематический `payload короче тега`.** Кадр повреждён до дешифрования — проверьте параметры
  кодеков и целостность радиотракта.
- **Очереди `ожидание продолжения свёрточного блока`.** Передатчик не присылает оставшиеся части.
  Проверьте таймауты и значения `frag_cnt`.
- **Высокие значения `deliver`.** Возможен узкий канал вывода (например, тяжёлый обработчик в GUI).
- **`ошибка AES-CCM`.** Ключи не синхронизированы или кадр подменён. После нескольких повторов стоит
  инициировать повторную загрузку ключа через `reloadKey()`.

## Связь с отображением в `ReceivedBuffer`

При успешном прохождении всех этапов данные поступают в `ReceivedBuffer::pushReady()`, а при
дроблении — промежуточно через `pushSplit()` и `pushRaw()`. Профилирование помогает отличить ситуации,
когда сообщение не появляется в интерфейсе из-за отсутствия кадров (например, `drop_stage =
"ожидание остальных частей split"`), от проблем отображения (при `deliver > 0`, но сообщение не
появилось, проверяйте обработчики списка).

