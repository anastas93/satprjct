# Структура ACK-пакета без дополнительного кодирования

Начиная с текущей версии подтверждения передаются тем же транспортным кадром,
что и пользовательские сообщения: полезные данные сопровождаются двумя копиями
`FrameHeader`, после чего выполняется только скремблирование. Шифрование и
свёрточное кодирование отключены, поэтому флаги `FLAG_ENCRYPTED` и
`FLAG_CONV_ENCODED` в заголовке не устанавливаются, а полезная нагрузка остаётся
в открытом виде.

## Формат кадра

| Смещение (байт) | Размер | Поле             | Описание |
|-----------------|--------|------------------|----------|
| 0               | 12     | `FrameHeader #1` | Основная копия заголовка. `frag_cnt = 1`, `packed`: `flags = 0`, `frag_idx = 0`, `payload_len = 1`. |
| 12              | 12     | `FrameHeader #2` | Дублированный заголовок с теми же значениями (CRC больше не используется). |
| 24              | 1      | `MARKER`         | Постоянный байт `0x06` (`protocol::ack::MARKER`). |

Размер кадра в эфире составляет 25 байт. Пилотные вставки не добавляются, так как
полезная нагрузка занимает всего один байт и не достигает порога через каждые 64
символа.

## Особенности обработки

* **TxModule** формирует ACK отдельной очередью, но при передаче
  сознательно пропускает стадии AEAD и `conv_codec::encodeBits()`.
  Это гарантирует, что полезная нагрузка состоит только из маркера,
  а в заголовке отсутствуют флаги шифрования и свёрточного кодирования.
* **RxModule** проверяет флаги заголовка и длину полезной нагрузки.
  Если перед ним ACK без шифрования и свёртки, модуль не пытается выполнять
  дешифрование или декодирование и сразу уведомляет передатчик через
  `ack_cb_()`. Полезная нагрузка (`0x06`) дополнительно передаётся в основной
  колбэк.
Благодаря единообразной структуре ACK легко проходят через существующие
мониторинговые инструменты, при этом задержка подтверждения остаётся минимальной
из-за отсутствия дополнительного кодирования.
