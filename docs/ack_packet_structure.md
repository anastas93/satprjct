# Структура компактного ACK-пакета

Начиная с данной версии подтверждение передаётся отдельным компактным фреймом без заголовка `FrameHeader` и без вставки пилотных маркеров. Радио получает готовую последовательность байтов и отправляет её напрямую, поэтому накладные расходы на кодирование и контрольные суммы отсутствуют.

## Формат

| Смещение (байт) | Размер | Поле            | Описание |
|-----------------|--------|-----------------|----------|
| 0               | 1      | `MARKER`        | Постоянный байт `0x06` (`protocol::ack::MARKER`). Показывает, что пакет является подтверждением. |
| 1               | 0..4   | `msg_id` (опц.) | Дополнительная часть, в которой можно передать младшие байты идентификатора сообщения. Сейчас не заполняется, но диапазон зарезервирован для совместимости. |

Минимальный ACK состоит из одного байта `0x06` и выглядит следующим образом:

```
+---------+
| 0x06    | ← `MARKER`
+---------+
```

Если в будущем потребуется указать конкретный идентификатор, младшие байты `msg_id` просто добавляются следом:

```
+---------+---------+---------+---------+---------+
| 0x06    | ID[3]   | ID[2]   | ID[1]   | ID[0]   |
+---------+---------+---------+---------+---------+
```

## Особенности обработки

* **TxModule** формирует ACK отдельной веткой и вызывает `IRadio::send()` непосредственно с подготовленным буфером. Это позволяет обойти шифрование, свёрточный кодек, вставку пилотов и дублирование заголовка.
* **RxModule** распознаёт компактный ACK по первому байту и длине (`<= 5`), уведомляет передатчик через `onAckReceived()` и отдаёт полезную нагрузку в колбэк, не пытаясь декодировать заголовок.
* Для обратной совместимости модуль приёма продолжает принимать устаревшие варианты (`"ACK"`, строки с префиксами и т.д.), но при формировании ответов используется именно бинарный формат.

Такой подход сокращает задержку подтверждения, уменьшает нагрузку на радиоканал и исключает лишние служебные поля, которые ранее добавлял общий цикл фрагментации.
