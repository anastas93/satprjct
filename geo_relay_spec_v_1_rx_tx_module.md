# Спецификация программы: Работа с геостационарным спутниковым ретранслятором

**Часть I. Модуль приёма/передачи (Rx/Tx)**  
Версия: 1.0 (черновик)  
Статус: для ревью

---

## 0. Цели и границы
**Цель:** определить архитектуру и интерфейсы базового модуля приёма/передачи, обеспечивающего обмен пакетами через геостационарный спутниковый ретранслятор (GEO) с жёсткой изоляцией от прикладной логики.

**Границы:**
- В этой части описываются: абстрактная прослойка (далее **ATL** — Abstract Transport Layer), буферы, QoS, планирование передачи, парсинг принятых пакетов и их диспетчеризация в обработчики (handlers).  
- Не описываются: конкретный PHY/SDR драйвер, криптография/ключевая инфраструктура, прикладные обработчики и генераторы полезной нагрузки (будут в частях II+).

**Ключевое правило:** никакой внешний компонент не вызывает Rx/Tx напрямую. Внешние компоненты работают только через ATL и её API буферов с QoS.

---

## 1. Требования
### 1.1 Функциональные
1. Приём кадров от PHY-адаптера, дефрейминг → извлечение пакетa → помещение в **Rx-буфер**.
2. Установка флага/события «RxReady», запуск **Parser/Dispatcher** → маршрутизация пакетов в зарегистрированные обработчики по типу/протоколу.
3. Принятие готовых пакетов от внешних продюсеров в **Tx-буфер** через ATL.put() c заданным классом QoS и метаданными.
4. Планирование и отправка (TxScheduler) по флагу/событию «TxReady» в PHY-адаптер через фреймер.
5. Горячее подключение/отключение обработчиков и генераторов без модификации ядра Rx/Tx.

### 1.2 Нефункциональные
- **Декуплинг:** добавление новых обработчиков/генераторов не меняет существующие.  
- **RT-детерминизм:** предсказуемая задержка очередей; неблокирующие пути.
- **Производительность (целевые, настраиваемые):**  
  - Пропускная способность: ≥ 2× требуемой полезной на канале, с учётом GEO.  
  - Доп. задержка ATL: ≤ 5 ms (однопроходно, при локальной памяти).  
- **Надёжность:** счётчики ошибок, backpressure, восстановление после переполнений.  
- **Портируемость:** Linux/RTOS (FreeRTOS/Zephyr).  

---

## 2. Термины и сокращения
- **PHY-адаптер** — драйвер/модем нижнего уровня (SDR/терминал).  
- **Кадр (Frame)** — единица передачи на канале.  
- **Пакет (Packet, PDU)** — полезная нагрузка ATL.  
- **Generator** — компонент, создающий исходящие пакеты (beacon/telemetry/ACK).  
- **Handler** — компонент, обрабатывающий входящие пакеты конкретного типа.  

---

## 3. Обзор архитектуры
```
[Producers/Apps]   [Generators]          [Handlers]
      |                |                      ^
      v                v                      |
            +-------------------------------+
            |  ATL: Abstract Transport Layer|
            |  - API put/get                |
            |  - QoS, метаданные            |
            |  - Tx/Rx буферы (lock-free)   |
            +-------------------------------+
                 |                 ^
                 v                 |
           [TxScheduler]      [Parser/Dispatcher]
                 |                 ^
                 v                 |
             [Framer] <--> [Deframer]
                 |                 ^
                 v                 |
               [PHY адаптер / модем]
```

Основная идея: весь обмен с внешними компонентами идёт через ATL. Rx/Tx ядро «видит» только буферы и события.

---

## 4. Модель данных
### 4.1 Пакет ATL
```c
struct AtlPacket {
  uint16_t proto_id;      // идентификатор протокола/типа (регистритруется обработчиком)
  uint8_t  qos_class;     // класс обслуживания (см. 4.2)
  uint8_t  flags;         // ACK_REQ, ENCRYPTED и т.п.
  uint32_t seq;           // последовательный номер (по желанию)
  uint64_t t_created_ns;  // метка времени создания
  uint32_t len;           // длина payload
  uint8_t* payload;       // указатель на полезные данные
  AtlMeta  meta;          // произвольные метаданные (key/value, фикс. пул)
};
```

### 4.2 Классы QoS (по умолчанию)
| Class | Назначение            | Очередь | Политика        | Ограничения |
|------:|------------------------|--------:|-----------------|-------------|
| 0     | Управление/сигналинг   |   high  | strict priority | rate-limit  |
| 1     | Теле/ACK критичные     |   high  | WFQ weight=4    | jitter cap  |
| 2     | Телеметрия             | medium | WFQ weight=2    | —           |
| 3     | Bulk/фоновая           |  low   | WFQ weight=1    | —           |

### 4.3 Кадр PHY (общее)
```c
struct PhyFrame {
  uint16_t frame_type;    // тип кадра (data, ctrl, keepalive...)
  uint16_t frame_len;
  uint8_t  frame_payload[MAX_FRAME];
  uint32_t fcs;           // CRC/FCS
};
```

ATL → Framer: один или несколько AtlPacket упаковываются в PhyFrame согласно профилю канала (MTU, FEC, padding).

---

## 5. Буферы и синхронизация
### 5.1 Структура буферов
- **Tx-буфера:** отдельные lock-free кольца на класс QoS (например, по 256 дескрипторов).  
- **Rx-буфер:** общее lock-free кольцо входящих пакетов (descriptor+payload ref).  
- **Водяные знаки:** high/low watermark для backpressure.

### 5.2 События/флаги
- **TxReady:** устанавливается при появлении пакета в любой Tx-очереди.  
- **RxReady:** устанавливается при помещении пакета в Rx-буфер.  
Реализация: семафоры/эвенты RTOS или eventfd/epoll на Linux. Без busy-wait.

### 5.3 Политики backpressure
- ATL.put() → `OK` / `E_AGAIN` (очередь заполнена) / `E_QOS_DENIED` / `E_SIZE`.  
- Для критичных классов (0/1) разрешён малый блокирующий timeout (конфигурируемый).

---

## 6. Планирование передачи (TxScheduler)
- Сканирование очередей QoS по политике **StrictPriority(0) → WFQ(1..3)**.  
- Пакеты изымаются до достижения MTU/MRU кадра.  
- **RateLimiter**: общий бюджет канала (бит/с) + per-class лимиты.  
- **Shaper**: сглаживание джиттера для классов 0/1.  
- **RetryPolicy** (опционально, если нет нижнего ARQ): N попыток/таймер RTO.

---

## 7. Приём, парсинг и диспетчеризация
1. PHY → Deframer: проверка FCS, FEC-статус → извлечь AtlPacket(ы).  
2. Поместить в Rx-буфер, поднять `RxReady`.  
3. **Parser/Dispatcher**: по `proto_id` ищет обработчик в реестре и отдаёт пакет в его входную очередь.  
4. Если обработчика нет — статистика «orphan» и политика: drop/trace/forward-to-default.

### 7.1 Реестр обработчиков/генераторов
```c
typedef AtlStatus (*AtlHandlerFn)(const AtlPacket*);

typedef struct {
  uint16_t proto_id;
  AtlHandlerFn on_packet;
  uint32_t caps;       // флаги возможностей
  uint32_t version;    // для совместимости
} AtlHandlerDesc;

AtlStatus atl_register_handler(const AtlHandlerDesc*);
AtlStatus atl_unregister_handler(uint16_t proto_id);
```

Генераторы регистрируют таймеры/триггеры и публикуют пакеты через ATL.put().

---

## 8. Интерфейсы ATL (внешние)
```c
// Публикация исходящих пакетов
AtlStatus ATL_put(const AtlPacket* pkt, uint32_t timeout_ms);

// Подписка обработчика (внутренне через реестр)
AtlStatus ATL_register_handler(const AtlHandlerDesc* desc);

// Телеметрия
AtlStats ATL_get_stats(void);

// Конфигурация
AtlStatus ATL_set_qos(const AtlQosProfile* profile);
AtlStatus ATL_set_limits(const AtlRateLimits* limits);
```

**Гарантии:** порядок доставки не гарантируется между классами QoS; внутри класса — best-effort FIFO.

---

## 9. Состояния и автоматы
### 9.1 Tx FSM
- **IDLE** → (TxReady) → **SCHEDULE** → **FRAME** → **SEND** → (OK) **IDLE** / (E_IO) **RECOVER**.

### 9.2 Rx FSM
- **WAIT_FRAME** → **DEFRAme** → **ENQUEUE_RX** → **DISPATCH** → **WAIT_FRAME**.

Режимы отказа: **RECOVER** инициирует сброс очереди/PHY-линка по политике, метрики ошибок увеличиваются.

---

## 10. Конфигурация
YAML-профиль (пример):
```yaml
atl:
  rx_ring_size: 512
  tx_ring_sizes: { q0: 128, q1: 256, q2: 256, q3: 256 }
  rate_limits:
    total_bps: 1200000
    class_bps: { q0: 80000, q1: 300000, q2: 500000, q3: 300000 }
  retry:
    enabled: false
    max_retries: 2
    rto_ms: 750
  timers:
    beacon_ms: 5000
    keepalive_ms: 2000
  orphan_policy: drop # drop|trace|default
```

---

## 11. Метрики и логирование
- Счётчики: tx_ok, tx_drop_qos, tx_eagain, rx_ok, rx_crc_err, orphan, dispatcher_queue_full.  
- Таймеры: latency_put→send, rx_deframe_time, dispatch_time.  
- Экспозиция: Prometheus/CBOR/Plaintext.

---

## 12. Потоки/задачи (референс)
- **Task Tx** (prio high-1): ждёт `TxReady`, планирует, кадрирует, пишет в PHY.  
- **Task Rx** (prio high): читает из PHY, дефреймит, кладёт в Rx-буфер.  
- **Task Disp** (prio medium): парсит/раскидывает.  
- **Task Gen** (prio low): генераторы (таймерные триггеры).  
Очереди: lock-free MPSC; избегаем общих мьютексов в горячих путях.

---

## 13. Совместимость и версионирование
- `proto_id` пространство: 0x0000–0x7FFF — зарезервировано системой; 0x8000–0xFFFF — пользовательские.  
- Версии обработчиков — семантика SemVer; несовместимость → отказ регистрации.

---

## 14. Безопасность (скелет)
- Маркеры **ENCRYPTED**, **AUTHED** в `flags`.  
- Хуки для шифрования/аутентификации на уровне Framer/Deframer (плагины).  
- Zero-copy с контролем длины, проверка границ, защитa от дубликатов по `seq` (опц.).

---

## 15. Тестирование
- **Unit:** буферы, планировщик, парсер, регистрация/дерегистрация.  
- **Property-based:** целостность очередей при гонках.  
- **Load:** насыщение по QoS, измерение латентности и drop rate.  
- **Fault-injection:** падение PHY, CRC ошибки, переполнения.

---

## 16. Примеры потоков
**Исходящий:** Producer → ATL_put(pkt,q1) → TxReady → TxScheduler(WFQ) → Framer(MTU pack) → PHY.send().  
**Входящий:** PHY.recv() → Deframer(CRC ok) → Rx-буфер → RxReady → Dispatcher(proto_id=0x0201) → handler.on_packet().

---

## 17. Открытые вопросы (для следующих частей)
1. Конкретный профиль кадра (MTU, кодирование, FEC) под выбранный модем.  
2. Требования к крипто (AEAD? ключевой менеджмент).  
3. Политики ARQ/ACK на каком уровне — ниже/внутри ATL?  
4. Набор стандартных `proto_id` (telemetry, beacons, mgmt, file xfer).  
5. Контроль потоков между несколькими физ. каналами (мультилинк/инмарсат?).

---

## 18. Мини-референс API (языконейтрально)
```c
// Путь исходящих
ATL_put(pkt, timeout_ms) -> OK | E_AGAIN | E_DENIED | E_SIZE

// Регистрация обработчиков
ATL_register_handler({proto_id, on_packet, caps, version}) -> OK | E_DUP | E_INCOMP
ATL_unregister_handler(proto_id)

// Статистика
ATL_get_stats() -> { counters..., rates..., latency_histos... }

// Настройки QoS/лимитов
ATL_set_qos(profile)
ATL_set_limits(limits)
```

---

## 19. Примечания по портированию
- **Linux:** epoll + eventfd, io_uring (опц.), hugepages для буферов.  
- **RTOS (Zephyr/FreeRTOS):** таски + очереди MPSC, ISR → Deframer минимальный, без malloc в ISR.  
- **Zero-copy:** по возможности передавать указатели/дескрипторы, не копии payload.

---

## 20. Итог
Базовый модуль Rx/Tx изолирован абстракцией ATL. Новые обработчики/генераторы подключаются через реестр и не требуют изменения ядра. QoS и планировщик обеспечивают управляемую задержку и предсказуемость на GEO-канале.

