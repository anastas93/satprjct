# Минимальный модуль передачи и приёма

Минимальный набор компонентов для отправки и приёма сообщений по LoRa с поддержкой
шифрования, очередей QoS, веб-интерфейса и управлением через Serial/HTTP. Репозиторий
содержит как прошивку, так и вспомогательные библиотеки и средства тестирования.

## Содержание
- [Обзор проекта](#обзор-проекта)
- [Структура репозитория](#структура-репозитория)
- [Основные компоненты прошивки](#основные-компоненты-прошивки)
  - [Базовые классы](#базовые-классы)
  - [Модули обработки](#модули-обработки)
  - [Радиоинтерфейс](#радиоинтерфейс)
  - [Вспомогательные библиотеки](#вспомогательные-библиотеки)
- [Каталог `libs/`](#каталог-libs)
- [Веб-интерфейс](#веб-интерфейс)
  - [Общие возможности](#общие-возможности)
  - [Вкладка Chat](#вкладка-chat)
  - [Вкладка Pointing](#вкладка-pointing)
- [Вкладка Channels/Ping](#вкладка-channelsping)
  - [Вкладка Settings](#вкладка-settings)
  - [Вкладка Security](#вкладка-security)
  - [Вкладка Debug](#вкладка-debug)
- [HTTP API](#http-api)
- [Хранилище ключей и обмен](#хранилище-ключей-и-обмен)
  - [Генерация и передача ключей](#генерация-и-передача-ключей)
  - [Тест шифрования ENCT](#тест-шифрования-enct)
  - [Специальный корневой ключ](#специальный-корневой-ключ)
- [Справочник API](#справочник-api)
  - [MessageBuffer](#messagebuffer)
  - [ReceivedBuffer](#receivedbuffer)
  - [PacketSplitter](#packetsplitter)
  - [PacketGatherer](#packetgatherer)
  - [FrameHeader](#frameheader)
  - [TxModule](#txmodule)
  - [RxModule](#rxmodule)
  - [RadioSX1262](#radiosx1262)
  - [SerialProgramCollector](#serialprogramcollector)
  - [TextConverter](#textconverter)
  - [`rs255223`](#rs255223)
  - [`conv_codec`](#conv_codec)
  - [`bit_interleaver`](#bit_interleaver)
  - [KeyLoader](#keyloader)
  - [AES-CCM](#aes-ccm)
- [Команды Serial](#команды-serial)
- [Пример последовательности обработки](#пример-последовательности-обработки)
- [Тестирование](#тестирование)
- [Что реализовано](#что-реализовано)
- [Что осталось сделать](#что-осталось-сделать)

## Обзор проекта
В форке сохранены только базовые элементы исходного проекта: очередь сообщений,
разбиение и сборка пакетов, радиомодуль SX1262, механизм шифрования AES-CCM и
сопутствующая инфраструктура. Штатная конфигурация рассчитана на работу как на ESP32,
так и на ПК.

Прошивка умеет:
- отправлять и принимать фрагментированные сообщения с подтверждениями ACK;
- применять код Рида–Соломона, байтовый и битовый интерливинг, свёрточное кодирование и
  скремблирование;
- вести журнал статусов, управлять радиопараметрами и обмениваться ключами шифрования;
- предоставлять веб-интерфейс для чата и настройки устройства.

## Структура репозитория
- `tx_module.cpp`, `rx_module.cpp`, `message_buffer.cpp` — ядро обмена сообщениями;
- `radio_interface.h`, `radio_sx1262.*` — абстракция радиоинтерфейса и реализация для SX1262;
- `serial_radio_control.ino` — пример прошивки с Serial-командами и HTTP-интерфейсом;
- `web/` — встроенный клиент с вкладками Chat/Pointing/Channels/Settings/Security/Debug;
- `key_storage/` — файлы с ключами шифрования;
- `libs/` — сторонние и вспомогательные библиотеки (кодек, интерливинг, логгер и т.д.);
- `tests/` — набор проверок без реального радиоканала;
- `libs_includes.cpp` — единая точка подключения реализаций для Arduino.

## Основные компоненты прошивки

### Базовые классы
- **MessageBuffer** — очередь сообщений с ограничением по количеству элементов и доступом к
  идентификатору. Позволяет откатывать добавление и просматривать первый элемент без
  извлечения.
- **ReceivedBuffer** — буфер принятых элементов (RAW/SP/GO) с готовыми именами и снимками для
  команды `RSTS`.
- **PacketSplitter** — делит сообщение на блоки фиксированного размера либо пользовательской
  длины.
- **PacketGatherer** — объединяет части сообщения обратно в единый буфер и отслеживает
  завершение.
- **FrameHeader** — формирует и проверяет заголовок LoRa-кадра, включая CRC заголовка и
  полезной нагрузки.

### Модули обработки
- **TxModule** — отправка сообщений с учётом классов QoS, пауз между отправками и ожидания
  подтверждений. Ведёт журнал статусов, поддерживает прямую отправку через `prepareExternalSend`.
- **RxModule** — приём и расшифровка кадров, передача собранных сообщений в колбэк и (опционально)
  в `ReceivedBuffer`. Включает дешифрование AES-CCM и обратные преобразования кодирования.

### Радиоинтерфейс
- **IRadio** — контракт радиомодуля (описан в `radio_interface.h`).
- **RadioSX1262** — реализация интерфейса с настройкой банка каналов, полосы, SF, CR и
  мощности, а также методами пинга, маяка и получения последних RSSI/SNR.
- **DefaultSettings** — флаг `DEBUG`, уровни логирования, включение RS-кода/ACK, пауза между
  отправками, размер блока для `PacketGatherer` и значение `PING_WAIT_MS`.

### Вспомогательные библиотеки
- **SerialProgramCollector** (`libs/serial_program_collector/`) — собирает многострочные команды из
  Serial в единый буфер с контролем переполнения.
- **TextConverter** (`libs/text_converter/`) — преобразует текст между UTF-8 и CP1251, что
  используется при отправке сообщений и отображении входящих пакетов.
- **SimpleLogger** (`libs/simple_logger/`) — журнал статусов `ERR/PROG/GO` с перезаписью по
  префиксу и выдачей командой `STS`.
- Макросы `LOG_ERROR/LOG_WARN/LOG_INFO/DEBUG_LOG` фильтруют вывод по уровню и подавляют повторы;
  на Arduino вывод дополнительно сбрасывается через `Serial.flush()`.

## Каталог `libs/`
Каждая библиотека расположена в отдельной подпапке каталога `libs/`.

| Библиотека | Назначение |
|------------|------------|
| `rs255223` | Обёртки `encode()`/`decode()` для кода Рида–Соломона RS(255,223). |
| `byte_interleaver` | Байтовый интерливинг (`interleave`/`deinterleave`). |
| `conv_codec` | Свёрточное кодирование и декодирование (`encodeBits`/`viterbiDecode`). |
| `bit_interleaver` | Битовый интерливинг (`interleave`/`deinterleave`). |
| `scrambler` | Скремблирование кадра на основе LFSR (полином x^16 + x^14 + x^13 + x^11, seed `0xACE1`). |
| `frame` | Структуры заголовков кадров (`FrameHeader`). |
| `key_loader`, `crypto/aes_ccm`, `key_transfer` | Работа с ключами, AES-CCM и обмен корневым ключом. |
| `simple_logger`, `serial_program_collector`, `text_converter` | Логирование, сборка команд, преобразование текста. |

Файл `libs_includes.cpp` подключает реализации библиотек для Arduino-проекта и избавляет от
неявных зависимостей.

## Веб-интерфейс
Каталог `web/` содержит встраиваемый интерфейс с вкладками **Chat**, **Channels/Ping**, **Settings**,
**Security** и **Debug**. Страница отдаётся прошивкой напрямую из `web/web_content.h`, который
хранит строки `index.html`, `style.css`, `script.js` и `libs/sha256.js`.

### Общие возможности
- Единый адаптивный дизайн с навигацией, раскрывающейся поверх контента на мобильных устройствах.
- При переключении вкладок прокрутка блокируется, а активная вкладка подсвечивается.
- История сообщений и настройки сохраняются в `localStorage`; при его недоступности используется
  резервное хранение в памяти вкладки.
- Внизу страницы отображается подпись «Powered by AS Systems» с номером версии из `/ver`. После
  успешного чтения значение кэшируется в `localStorage`, поэтому отображается даже при временном
  отсутствии связи. Дополнительно используется команда `VER`, а ответы `unknown`/пустые строки
  очищают кэш и скрывают значение. Файл `ver` хранит версию в кавычках, благодаря чему прошивка
  получает резервное значение даже при отсутствии файла в SPIFFS.
- Переключатель темы поддерживает «красный» ночной режим и автоматическое включение по времени;
  автоматический режим можно отключить.
- Блок состояния показывает флаги ACK и шифрования: индикаторы работают как переключатели.

### Вкладка Chat
- Пузырьковое отображение истории сообщений с цветами для исходящих, входящих и системных
  сообщений.
- Команды можно отправлять напрямую через `/`, аргументы (`/ACK 0`, `/TX текст`) сохраняются в
  истории.
- Системные ответы выводятся курсивом уменьшенного кегля, подтверждение `TX` отображается внутри
  сообщения отправителя.
- Кнопки `BCN`, `TESTRXM` и блок отправки `TXL` вызывают служебные команды без ввода вручную.
- Полученные пакеты автоматически дублируются в чат: основное тело показывает полезную нагрузку из
  поля `text`, а под ним выводятся подписи `name` и `Len` в байтах. При восстановлении браузер
  пробует несколько кодировок и использует эвристики для борьбы с «кракозябрами» (`СЃР±…`), поэтому
  кириллица отображается корректно даже после двойного перекодирования. Старые записи с тегом
  `rx-name` нормализуются в формат `rx-message`.
- Если устройство сперва вернуло только имя `GO-xxxxx`, чат автоматически обновит запись и подставит
  текст сразу после появления полезной нагрузки в ответе `RSTS`.
- Монитор входящих сообщений опрашивает `RSTS full=1`, подсвечивает новые элементы, позволяет
  копировать имя одной кнопкой и ограничивает размер списка.
- Текст готовых сообщений `GO-xxxxx` восстанавливается из `hex` прямо в браузере (функции
  `hexToBytes`, `decodeBytesToText`, `resolveReceivedText`), поэтому в списке и в чате сразу
  отображается собранный payload, даже если прошивка отдаёт только шестнадцатеричный снимок.
- Команда `TESTRXM` формирует серию из пяти сообщений на основе фразы *Lorem ipsum*: четыре варианта
  содержат 100/50/30/20 % текста, а пятое проходит через эмуляцию `PacketGatherer` (создаются
  записи `R-`/`SP-`/`GO-`); задержка между генерациями составляет 0,5 секунды.

### Вкладка Pointing
- Верхняя сводка отображает состояние TLE, источник координат и количество видимых спутников. Кнопка «Запросить позицию» выполняет разовый запрос геолокации браузера, «Включить отслеживание» активирует `watchPosition`, а при необходимости координаты можно задать вручную. Для Safari на iOS добавлено явное предупреждение, если геолокация недоступна из-за незашифрованного подключения, с подсказкой по разрешению доступа.
- Панель горизонта визуализирует азимуты и возвышения доступных спутников в виде компактных круглых маркеров. Маркеры автоматически разводятся по вертикали, если аппараты находятся рядом по азимуту, и раскрывают подпись при наведении или выборе спутника; цвет маркера отражает квадрант (север/восток/юг/запад).
- Круговой радар внутри компаса отображает доступные спутники точками: азимут задаёт направление, возвышение влияет на расстояние от центра. Цветовая кодировка совпадает с панелью горизонта, а в верхней части циферблата добавлена метка «N» для северного направления. Навигация по точкам также переключает активный спутник.
- Карточка наблюдателя показывает широту, долготу, высоту и точность, фиксирует источник данных и время обновления.
- Датчики ориентации включаются отдельной кнопкой, при недоступности сенсоров доступен ручной ввод азимута и наклона.
- Компас визуализирует требуемый азимут и текущий курс устройства, шкала возвышения помогает совместить угол подъёма антенны. Подробная карточка отображает подспутниковые координаты, высоту орбиты и расстояние.
- Набор TLE встроен в `web/libs/geostat_tle.js` и формируется из файла `REF/tle.txt` скриптом `tools/generate_geostat_tle.py`, поэтому список спутников доступен офлайн.

### Вкладка Channels/Ping
- Таблица частот активного банка показывает частоты, RSSI, SNR, статус и результат сканирования.
- Текущий канал подсвечивается, строки получают классы `busy`, `free` или `unknown`.
- При клике открывается карточка с измерениями и справочными данными (System/Band Plan/Purpose).
  Данные берутся из `web/libs/freq-info.csv`, при недоступности — из встроенной копии.
- Карточка содержит кнопку «Установить текущим каналом» для мгновенного переключения радиомодуля.
- Кнопка **Search** последовательно пингует каналы активного банка, выделяя состояния классами
  `scanning`, `signal`, `crc-error`, `no-response`. Результаты можно экспортировать в CSV с полем
  `scan_state`.
- Обновление статусов во время сканирования выполняется через вспомогательную функцию `uiYield()`
  (`requestAnimationFrame` или `setTimeout`). Дополнительные функции: `detectScanState()`,
  `applyPingToEntry()`, `setChannelScanState()`.

### Вкладка Settings
- Поддерживает ввод `Endpoint`, управление BANK/BF/CH/CR/PW/SF и настройку количества повторов
  `ACKR` (при включённом подтверждении), паузы между отправками (`PAUSE`) и тайм-аута ACK (`ACKT`).
- Значения считываются с устройства при загрузке страницы, выбранный канал сохраняется в
  локальном хранилище и восстанавливается после перезапуска.
- Под выпадающим списком отображаются частоты RX/TX активного канала, подсказка рядом с `ACKR`
  показывает актуальные задержки.
- Поле «Сообщение для TESTRXM» позволяет задать текст для теста входящих сообщений (до 2048
  символов, ~2 КиБ); при пустом значении используется встроенный шаблон *Lorem ipsum*.

### Вкладка Security
- Управление ключами (`KEYSTATE`, `KEYGEN`, `KEYRESTORE`, `KEYTRANSFER SEND/RECEIVE`). Все операции
  дублируются в отладочный журнал.
- Реализация SHA-256 (`web/libs/sha256.js`) позволяет вычислять хеш ключа в среде без WebCrypto.
- Переключатель включает принудительное шифрование (даже для старых кадров без флага).
- Кнопка `KEYTRANSFER SEND` копирует публичный ключ в буфер обмена (при поддержке API браузера);
  `KEYTRANSFER RECEIVE` сопровождается мигающим индикатором ожидания.
- Блок ENCT показывает исходные данные, шифртекст, тег, nonce и результат дешифрования.

### Вкладка Debug
- Выводит отладочные сообщения, включая операции с ключами и ответы сервера.
- Поддерживает видимое выделение фокуса для ссылок и кнопок.
- Кнопки `RSTS FULL` и `RSTS JSON` выполняют запросы списка сообщений с разным форматом вывода и
  пишут подробный ответ в отладочный лог.
- Доступна выгрузка полного списка сообщений (`RSTS full json=1`) в файл `rsts-full-<timestamp>.json`
  одной кнопкой.

## HTTP API
- `POST /api/tx` — отправляет текст через `TxModule` (используется кнопкой «Отправить по радио»).
- `GET /cmd?c=<CMD>` и `GET /api/cmd?cmd=<CMD>` — выполнение команд (`PI`, `SEAR`, `BANK`, `CH`,
  `CHLIST`, `STS`, `RSTS`, `INFO`, `VER`). Параметры передаются через `v` или `bank`.
- HTTP-команды для настройки: `BF`, `SF`, `CR`, `PW`, `PAUSE`, `ACK`, `ACKR`, `ACKT`, `BCN`, `TXL`,
  `TX`.
- `GET /libs/geostat_tle.js` — отдаёт встроенный список TLE для офлайн-работы вкладки Pointing.
- Команды работы с ключами возвращают JSON (`KEYSTATE`, `KEYGEN`, `KEYRESTORE`, `KEYTRANSFER SEND`,
  `KEYTRANSFER RECEIVE`, а также совместимые `KEYSEND`/`KEYRECV`).
- Ответ `RSTS full=1` включает список элементов с полями `name`, `type`, `len`, `text`, `hex`.

## Хранилище ключей и обмен
- Ключи на ПК и ESP32 хранятся в `key_storage/key.stkey` (для ESP32 — в `SPIFFS` каталога `/keys`).
- Запись содержит корневую пару Curve25519, текущий симметричный ключ AES-CCM, соль нонсов и
  последний публичный ключ удалённой стороны.
- При генерации нового ключа предыдущий файл переименовывается в `key.stkey.old`; старая резервная
  копия удаляется перед созданием новой.

### Генерация и передача ключей
1. Вкладка **Security** показывает тип активного ключа (`LOCAL` или `EXTERNAL`), идентификатор
   (первые байты SHA-256 симметричного ключа), публичный корневой ключ и наличие резервной копии.
2. Кнопка **KEYGEN** генерирует новую пару Curve25519, обновляет симметричный ключ и сохраняет файл
   `key.stkey`, одновременно обновляя модули `TxModule` и `RxModule`.
3. **KEY RESTORE** возвращает `key.stkey` из `key.stkey.old` (если существует) и перечитывает ключи.
4. **KEYTRANSFER SEND** формирует защищённый LoRa-кадр с публичным ключом устройства, шифрует его
   корневым AES-ключом и отправляет партнёру; веб-интерфейс дополнительно копирует ключ в буфер
   обмена.
5. **KEYTRANSFER RECEIVE** ждёт защищённый кадр, расшифровывает его тем же корневым ключом, применяет
   полученный публичный ключ (ECDH) и помечает симметричный ключ как внешний. При тайм-ауте команда
   возвращает ошибку и отображает мигающий индикатор ожидания.

### Тест шифрования ENCT
Тестовая команда формирует короткое сообщение, шифрует его, расшифровывает обратно и выводит
результат сравнения.

Запуск теста на ПК:
```bash
g++ -I. tests/test_enct.cpp libs_includes.cpp -std=c++17 && ./a.out
```

Через Serial (в `serial_radio_control.ino`):
```text
ENCT
ENCT: успех
```

### Специальный корневой ключ
Обмен сообщениями `KEYTRANSFER` использует отдельный статический AES-ключ из `libs/key_transfer`.
Он шифрует только LoRa-кадры с публичными ключами и не влияет на рабочий симметричный ключ трафика.

## Справочник API

### MessageBuffer
- `MessageBuffer(size_t capacity)` — создать буфер с ограничением на число сообщений.
- `uint32_t enqueue(const uint8_t* data, size_t len)` — добавить сообщение, при переполнении вернуть
  `0`.
- `size_t freeSlots() const` — количество свободных слотов.
- `bool dropLast()` — удалить последнее сообщение (откат).
- `bool hasPending() const` — наличие сообщений.
- `bool pop(uint32_t& id, std::vector<uint8_t>& out)` — извлечь сообщение и его идентификатор.
- `const std::vector<uint8_t>* peek(uint32_t& id) const` — указатель на данные первого сообщения без
  извлечения.

### ReceivedBuffer
- `std::string pushRaw(uint32_t id, uint32_t part, const uint8_t* data, size_t len)` — сохранить
  сырой пакет и получить имя `R-000000|номер`.
- `std::string pushSplit(uint32_t id, const uint8_t* data, size_t len)` — сохранить объединённые
  данные `SP-00000`.
- `std::string pushReady(uint32_t id, const uint8_t* data, size_t len)` — сохранить готовые данные
  `GO-00000`.
- `Item::name` хранит заранее подготовленную подпись, повторные обращения не требуют форматирования.
- `bool popRaw(Item& out)`, `bool popSplit(Item& out)`, `bool popReady(Item& out)` — извлечь данные.
- `std::vector<std::string> list(size_t count)` — имена первых элементов (не более `count`).
- `std::vector<SnapshotEntry> snapshot(size_t count)` — копия первых элементов с типом очереди для
  формирования JSON-ответа `RSTS`.

### PacketSplitter
- `PacketSplitter(PayloadMode mode, size_t custom = 0)` — создать делитель с нужным режимом или
  произвольным размером блока.
- `void setMode(PayloadMode mode)` и `void setCustomSize(size_t custom)` — сменить режим и размер.
- `uint32_t splitAndEnqueue(MessageBuffer& buf, const uint8_t* data, size_t len)` — разбить данные на
  части с проверкой свободных слотов и откатом при ошибке.

### PacketGatherer
- `PacketGatherer(PayloadMode mode, size_t custom = 0)` — создать собиратель.
- `void reset()` — очистить состояние.
- `void add(const uint8_t* data, size_t len)` — добавить часть сообщения.
- `bool isComplete() const` — проверить завершение сбора (актуально при фиксированном размере блока).
- `const std::vector<uint8_t>& get() const` — получить готовое сообщение.

### FrameHeader
- `bool encode(uint8_t* out, size_t out_len, const uint8_t* payload, size_t payload_len)` — записать
  заголовок в буфер и подсчитать CRC.
- `static bool decode(const uint8_t* data, size_t len, FrameHeader& out)` — разобрать заголовок и
  проверить CRC.
- `static uint16_t crc16(const uint8_t* data, size_t len)` и `bool checkFrameCrc(...)` — контрольные
  суммы заголовка и кадра.

### TxModule
- `TxModule(IRadio& radio, const std::array<size_t,4>& capacities, PayloadMode mode)` — инициализация
  с четырьмя очередями QoS.
- `void setPayloadMode(PayloadMode mode)` — сменить размер пакета.
- `uint32_t queue(const uint8_t* data, size_t len, uint8_t qos = 0)` — добавить сообщение в очередь.
- `void loop()` — отправить первое сообщение, если готово.
- `void setSendPause(uint32_t pause_ms)` и `uint32_t getSendPause() const` — пауза между отправками.
- `void setAckTimeout(uint32_t timeout_ms)` и `uint32_t getAckTimeout() const` — управление тайм-аутом
  ожидания ACK.
- `void prepareExternalSend()` / `void completeExternalSend()` — учёт глобальной паузы при внешней
  отправке через `RadioSX1262`.
- При ожидании подтверждения радиоинтерфейс переводится в режим приёма; пауза применяется между
  частями одного сообщения.
- Последовательность кодирования: `rs255223::encode()` → `byte_interleaver::interleave()` →
  `conv_codec::encodeBits()` → (опционально) `bit_interleaver::interleave()` → `scrambler::scramble()`.

### RxModule
- `void setCallback(RxModule::Callback cb)` — обработчик входящих данных.
- `void onReceive(const uint8_t* data, size_t len)` — принять кадр, проверить CRC и передать данные.
- `void setBuffer(ReceivedBuffer* buf)` — привязать буфер для автоматического сохранения сообщений.
- Буферы кадра, полезной нагрузки и результата переиспользуются между вызовами.
- Обратная цепочка обработки: `scrambler::descramble()` → (опционально)
  `bit_interleaver::deinterleave()` → `conv_codec::viterbiDecode()` →
  `byte_interleaver::deinterleave()` → `rs255223::decode()`.

### RadioSX1262
- `bool begin()` — инициализация радиомодуля с возвратом параметров к значениям по умолчанию.
- `void send(const uint8_t* data, size_t len)` — отправка пакета.
- `bool ping(...)` — пинг с ожиданием эха и возвратом параметров приёма.
- `void loop()` и `void setReceiveCallback(...)` — обработка готовности пакета и регистрация колбэка.
- `float getLastSnr() const`, `float getLastRssi() const` — параметры последнего пакета.
- `uint8_t randomByte()` — случайный байт от радиомодуля.
- Настройка и получение параметров: `setBank`, `setChannel`, `setBandwidth`, `setSpreadingFactor`,
  `setCodingRate`, `setPower`, `getBank`, `getChannel`, `getBankSize`, `getBandwidth`, `getSpreadingFactor`,
  `getCodingRate`, `getPower`, `getRxFrequency`, `getTxFrequency`.
- `static uint16_t bankSize(ChannelBank bank)`, `static float bankRx(...)`, `static float bankTx(...)` —
  справочные методы.
- `bool resetToDefaults()` — возврат параметров к значениям по умолчанию.

### SerialProgramCollector
- `void resetBuffer()` — очистить буфер.
- `bool appendToBuffer(const String& line)` — добавить строку с проверкой переполнения.

### TextConverter
- `std::vector<uint8_t> utf8ToCp1251(const std::string& in)` — UTF-8 → CP1251.
- `std::string cp1251ToUtf8(const std::vector<uint8_t>& data)` — CP1251 → UTF-8 (неизвестные символы
  заменяются на `?`).

### `rs255223`
- `void encode(const uint8_t* in, uint8_t* out)` — кодирует 223 байта в 255.
- `bool decode(const uint8_t* in, uint8_t* out)` — декодирует 255 байт и возвращает 223 байта.

### `conv_codec`
- `void encodeBits(const uint8_t* in, size_t len, std::vector<uint8_t>& out)` — свёрточное кодирование
  (R=1/2).
- `bool viterbiDecode(const uint8_t* in, size_t len, std::vector<uint8_t>& out)` — декодирование
  алгоритмом Витерби.

### `bit_interleaver`
- `void interleave(uint8_t* buf, size_t len)` — битовый интерливинг.
- `void deinterleave(uint8_t* buf, size_t len)` — обратный интерливинг.

### KeyLoader
- `std::array<uint8_t,16> loadKey()` — загрузить активный симметричный ключ (при отсутствии
  создаётся запись по умолчанию).
- `bool saveKey(const std::array<uint8_t,16>& key, KeyOrigin origin, const std::array<uint8_t,32>* peer,
  uint32_t salt)` — сохранить ключ с указанием происхождения и публичного ключа собеседника.
- `bool generateLocalKey(KeyRecord* out = nullptr)` — создать новую пару Curve25519, обновить
  симметричный ключ и резервную копию.
- `bool restorePreviousKey(KeyRecord* out = nullptr)` — восстановить `key.stkey` из резервной копии.
- `bool applyRemotePublic(const std::array<uint8_t,32>& remote)` — вычислить общий секрет и сохранить
  внешний симметричный ключ.
- `KeyState getState()` — текущее состояние ключа (тип, идентификатор, публичные ключи, резервная
  копия).
- `std::array<uint8_t,12> makeNonce(uint32_t msg_id, uint16_t frag_idx)` — сформировать nonce для
  AES-CCM.

### AES-CCM
- `bool encrypt_ccm(...)` — шифрование с формированием тега.
- `bool decrypt_ccm(...)` — проверка тега и расшифровка.

## Команды Serial
- `BANK <e|w|t|a>` — выбрать банк каналов.
- `CH <номер>` — переключить канал в текущем банке.
- `PI` — отправить пинг, ожидать эхо `PING_WAIT_MS` миллисекунд и вывести RSSI/SNR либо `timeout`.
- `SEAR` — последовательный пинг всех каналов с выводом RSSI/SNR и отметкой времени ожидания.
- `ACK [0|1]` — включить/выключить подтверждения.
- `KEYTRANSFER SEND` — отправить публичный корневой ключ по защищённому каналу.
- `KEYTRANSFER RECEIVE` — ожидать защищённый кадр и применить ключ при успехе.
- Дополнительно доступны команды `BF`, `SF`, `CR`, `PW`, `TX`, `TXL`, `BCN`, `INFO`, `STS <n>`,
  `RSTS <n>` (список имён) / `RSTS FULL <n>` (`RSTS JSON <n>` для вывода JSON с данными),
  `ACKR <повторы>`, `PAUSE <мс>`, `ACKT <мс>`, `ENC [0|1]`, `TESTRXM`.

## Пример последовательности обработки
```text
// Передача
шифрование -> PacketSplitter (223 байта) -> rs255223::encode ->
byte_interleaver::interleave -> conv_codec::encodeBits ->
bit_interleaver::interleave -> scrambler::scramble -> отправка

// Приём
scrambler::descramble -> bit_interleaver::deinterleave ->
conv_codec::viterbiDecode -> byte_interleaver::deinterleave ->
rs255223::decode -> PacketGatherer -> обработка сообщения
```

## Тестирование
- Комплексный тест полного цикла без радиоканала:
  ```bash
  g++ -I. -I.. tests/test_processing_without_send.cpp tx_module.cpp rx_module.cpp \
      message_buffer.cpp libs_includes.cpp -std=c++17 && ./a.out
  ```
- Базовые тесты буфера сообщений, делителя пакетов и формирования кадров находятся в каталоге
  `tests/`.
- Тест совместимости `RxModule` с внешним `ReceivedBuffer` подтверждает корректное отображение
  готовых сообщений.

## Что реализовано
- **Радиотракт**: отправка и приём сообщений, пинг, маяк, управление параметрами SX1262, возврат к
  настройкам по умолчанию, поддержка банков каналов `EAST/WEST/TEST/ALL` и командой `ALL` через
  Serial.
- **Очереди и QoS**: четыре очереди приоритетов, маркировка частей случайным идентификатором, журнал
  статусов `ERR/PROG/GO`, пауза между отправками, глобальная пауза для внешних отправок.
- **Кодирование и шифрование**: RS(255,223) с байтовым и битовым интерливингом, свёрточное кодирование,
  скремблирование, AES-CCM для фрагментов, управление подтверждениями ACK.
- **Ключи и безопасность**: генерация/восстановление ключей Curve25519, обмен публичными ключами по
  LoRa (`KEYTRANSFER SEND/RECEIVE`), загрузка ключей из файлов `key_storage`, отдельный корневой
  AES-ключ для передачи ключей, отображение состояния в веб-интерфейсе.
- **Инструменты и тесты**: комплексные и модульные проверки, команда ENCT, пример
  `serial_radio_control.ino` с 160-слотовыми очередями, `DefaultSettings` для параметров по умолчанию.
- **Веб-интерфейс**: чат с автоматическим дублированием `RX`, автообновление буфера, быстрые команды,
  управление ACK/шифрованием, настройка радиопараметров, пинг каналов, экспорт результатов сканирования,
  управление ключами, ночной режим, ручное/авто сохранение настроек и тем, вкладка Pointing со сводкой
  по TLE и координатам, визуальным горизонтом, компасом и настройкой датчиков ориентации.

## Что осталось сделать
- **Радио и планирование**
  - Расширить управление радиомодулем дополнительными командами и параметрами.
  - Внедрить планировщик WFQ для классов QoS.
- **Наведение антенны**
  - Автоматически обновлять TLE и напоминать пользователю о необходимости актуализации данных.
  - Добавить учёт горизонта и препятствий (маски высоты) и визуальную подсказку с картой линии визирования.
- **Обработка сигнала**
  - Реализовать обработку пилотов в RxPipeline (`updatePhaseFromPilot`) вместо простого удаления.
  - Доработать алгоритмы коррекции ошибок и добавить дополнительные схемы шифрования при необходимости.
- **Текст и совместимость**
  - Добавить поддержку дополнительных кодировок и символов в `TextConverter`.
  - Сохранение собранной программы и расширенную обработку команд завершения в SerialProgramCollector.
- **Тесты и верификация**
  - Покрыть тестами приём и обработку пилотов.
  - Добавить отдельные тесты/настройки для битового интерливинга и свёрточного кодека.
