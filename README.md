# Минимальный модуль передачи и приёма

В форке оставлены только базовые компоненты:

- `MessageBuffer` — простой буфер сообщений с ограничением по размеру.
- `ReceivedBuffer` — буфер принятых сообщений с разделением на raw/SP/GO форматы.
- `PacketSplitter` — делитель пакетов с тремя режимами размера полезной нагрузки.
- `PacketGatherer` — собиратель пакетов обратно в сообщение.
- `TxModule` — передача данных через интерфейс `IRadio`.
- `RxModule` — приём данных и передача их в пользовательский колбэк.
- `FrameHeader` — заголовок кадра с функциями `encode()` и `decode()`.
- `IRadio` описан в `radio_interface.h`.
- `RadioSX1262` — конкретная реализация интерфейса на базе модуля SX1262.
- `SerialProgramCollector` — библиотека для приёма строк по Serial и сборки их в один буфер (`libs/serial_program_collector/`).
- `serial_radio_control.ino` — пример настройки банков каналов, BW, SF, CR и мощности через Serial, вывода текущих параметров и отправки тестовых пакетов через `TxModule`, включая команды `TXL` для больших сообщений, `STS <n>` для просмотра журнала, `RSTS <n>` для просмотра содержимого `ReceivedBuffer`, `PI` для пинга и `SEAR` для поиска по всем каналам.
- `TextConverter` — библиотека (`libs/text_converter/`) для преобразования текста между UTF-8 и CP1251 (`utf8ToCp1251`, `cp1251ToUtf8`), используется командой `TX` и при выдаче расшифрованных входящих сообщений.
- `rs255223` — библиотека (`libs/rs255223/`) с обёртками `encode()` и `decode()` для кода Рида–Соломона RS(255,223).
- `byte_interleaver` — библиотека (`libs/byte_interleaver/`) с функциями `interleave()` и `deinterleave()` для байтового перемежения.
- `conv_codec` — библиотека (`libs/conv_codec/`) с функциями `encodeBits()` и `viterbiDecode()` для свёрточного кодирования.
- `bit_interleaver` — библиотека (`libs/bit_interleaver/`) с функциями `interleave()` и `deinterleave()` для битового перемежения.
  - `scrambler` — библиотека (`libs/scrambler/`) с функциями `scramble()` и `descramble()` на основе LFSR
  (полином x^16 + x^14 + x^13 + x^11, стартовое значение 0xACE1).
- `SimpleLogger` — библиотека (`libs/simple_logger/`) для записи статусов `ERR/PROG/GO` и вывода их командой `STS`. Повторная запись с одинаковым префиксом перезаписывает предыдущий статус.
- Для отладочных сообщений предусмотрен флаг `DefaultSettings::DEBUG` и уровни журналирования `DefaultSettings::LOG_LEVEL`. Доступны макросы `LOG_ERROR`, `LOG_WARN`, `LOG_INFO`, `DEBUG_LOG` и их варианты с выводом значения (`*_VAL`) для фильтрации лишнего спама. Последовательные одинаковые строки автоматически подавляются, а на Arduino вывод дополнительно сбрасывается через `Serial.flush()`.

Все сторонние библиотеки расположены в каталоге `libs/`.
Для корректной сборки в Arduino добавлен вспомогательный файл `libs_includes.cpp`,
который явно подключает реализации библиотек.

## Веб-интерфейс
В каталоге `web/` расположен интерфейс с пятью вкладками **Chat**, **Channels/Ping**, **Settings**, **Security** и **Debug**, оформленными в одном стиле.
Чат показывает историю сообщений пузырьками и позволяет отправлять команды устройству.
Системные ответы выделяются отдельным оттенком, а подтверждение `TX` теперь появляется прямо внутри пузырька отправителя крупной подписью без отдельного служебного сообщения, что делает лог похожим на привычные мессенджеры.
Навигация на мобильных устройствах раскрывается поверх контента с затемняющим оверлеем и блокировкой прокрутки, поэтому переключение вкладок удобно даже на узких экранах.
Под блоком команд размещён монитор принятых сообщений: интерфейс запрашивает `RSTS` с параметром `full=1`, получает JSON со списком элементов (`name`, `type`, `len`, `text`, `hex`), показывает содержимое входящих сообщений вместе с именем и подсвечивает новые элементы. Список поддерживает автообновление, ограничение по количеству и копирование имени в буфер обмена одним кликом.
Каждый принятый пакет автоматически дублируется в чат как сообщение `RX · <текст>`. При загрузке истории старые записи с тегом `rx-name` автоматически нормализуются в формат `rx-message`, чтобы все приёмы имели единый стиль и набор метаданных (`len`, `type`, `hex`). В журнале такие записи получают отдельный зелёный оттенок и подпись RX, поэтому их легко отличить от системных ответов.
Кнопка `TESTRXM` запускает генерацию пяти тестовых входящих сообщений длиной от 12 до ~80 символов с задержкой 0,5 секунды между элементами; UI автоматически опрашивает буфер, чтобы показать новые `GO-xxxxx` без ручного обновления.
Вкладка каналов строит таблицу частот из активного банка и поддерживает пинг/поиск.
Из таблицы убраны столбцы BW, SF, CR и PW, остаются только частоты, RSSI, SNR, статус и результат сканирования.
Текущий канал подсвечивается, а строкам назначаются классы `busy`, `free` или `unknown` в зависимости от статуса.
При клике по строке справа появляется карточка с текущими измерениями и справочными сведениями (System, Band Plan, Purpose), подгружаемыми из `web/libs/freq-info.csv`; при недоступности файла автоматически используется встроенная копия справочника.
Карточка подбирает данные справочника по частоте передачи, поэтому частоты всегда берутся из глобального CSV независимо от активного банка, а сведения не пропадают после обновления списка каналов.
Внутри карточки добавлена кнопка «Установить текущим каналом», позволяющая переключить радиомодуль на выбранную строку без перехода к настройкам.
Кнопка **Search** запускает последовательный пинг каждого канала активного банка: текущая строка выделяется голубым (`scanning`), ответившие каналы — зелёным (`signal`), пакеты с ошибкой CRC — оранжевым (`crc-error`), каналы без ответа — серым (`no-response`). Повторное нажатие останавливает цикл. Результаты можно выгрузить в CSV с дополнительным столбцом `scan_state`.
Для корректного обновления подписи состояния и таблицы во время сканирования добавлена вспомогательная функция `uiYield()` в `web/script.js`, которая уступает управление циклу отрисовки через `requestAnimationFrame` (при его отсутствии используется `setTimeout`).
Для разбора ответов и подсветки строк в `web/script.js` добавлены вспомогательные функции `detectScanState()`, `applyPingToEntry()` и `setChannelScanState()`.
В разделе Settings доступен переносной ввод `Endpoint`, управление BANK, BF, CH, CR, PW и SF, а также настройки количества повторов `ACKR` (доступна при включённом подтверждении), минимальной паузы между отправками (`PAUSE`) и тайм-аута ожидания ACK в миллисекундах (`ACKT`). Форма автоматически подтягивает актуальные значения с устройства при загрузке страницы, поэтому настройки не сбрасываются после перезагрузки. Выбранный канал сохраняется в локальном хранилище и автоматически восстанавливается в выпадающем списке и таблице после перезапуска интерфейса. Выбор канала применяет настройку немедленно и тут же обновляет отображение текущего состояния.
Под выпадающим списком Channel отображаются частоты RX/TX выбранного канала в приглушённом цвете.
Подсказка рядом с `ACKR` показывает актуальную паузу и тайм-аут ACK в миллисекундах, чтобы настройки повторов были нагляднее.
Вкладка Debug выводит отладочные сообщения.
После подключения к точке доступа страница открывается по адресу `http://192.168.4.1/`. Внизу страницы отображается подпись «Powered by AS Systems» с номером версии, запрашиваемым по маршруту `/ver`.
Если устройство возвращает `unknown` или пустой номер версии, подпись скрывает значение и оставляет прочерк вместо `vunknown`.
Файл `web/web_content.h` содержит строки `index.html`, `style.css`, `script.js` и библиотеку `libs/sha256.js`, подключённые напрямую без конвертации в массивы.
Отдельный файл `index.html` удалён, вся разметка хранится только в `web_content.h`.
Логика работы интерфейса находится в `web/script.js` и отвечает за переключение вкладок, отправку команд и сохранение настроек.
Для расчёта хеша ключа на вкладке Security добавлена чистая JS‑реализация SHA-256 (`web/libs/sha256.js`), позволяющая работать в HTTP‑среде без WebCrypto.
Чат дополнен блоком состояния ACK и шифрования: оба индикатора работают как переключатели режима, рядом оставлена компактная кнопка ручного обновления ACK.
Все действия с ключами (`KEYSTATE`, `KEYGEN`, `KEYRESTORE`, `KEYTRANSFER`) дополнительно дублируются в отладочный лог для наглядной истории операций.
Все системные сообщения в окне чата отображаются курсивом и уменьшенным кеглем, что делает поток сообщений визуально легче.
Кнопки `BCN` и `TESTRXM`, а также блок отправки `TXL` позволяют вызывать служебные команды без ввода через текстовое поле. Тест `ENCT` перенесён в раздел Security рядом с блоком управления ключами. Рядом с переключателем темы можно включить «красную» ночную подсветку, а автоматический ночной режим ориентируется на системное время (по умолчанию активен с 21:00 до 07:00). Автопереключение можно отключить — настройка запоминается и тема больше не меняется сама.
Ввод команд через `/` поддерживает передачу аргументов (`/ACK 0`, `/STS 5`, `/TX Привет`) и автоматически сохраняет историю в `localStorage`.
Если браузер блокирует `localStorage` (например, в приватном режиме), интерфейс переключается на резервное хранение в памяти вкладки, поэтому вкладки и выбор темы продолжают работать.

### HTTP API
- `POST /api/tx` — принимает текст в теле запроса и отправляет его через `TxModule`.
- В веб-интерфейсе добавлена кнопка «Отправить по радио», использующая этот эндпоинт.
- `GET /cmd?c=<CMD>` — выполнение команды (`PI`, `SEAR`, `BANK`, `CH`, `CHLIST`, `STS`, `RSTS`, `INFO`). Параметры передаются через `v` или `bank`.
- `GET /api/cmd?cmd=<CMD>` — совместимый адрес для тех же команд.
- Через HTTP доступны команды настройки радиопараметров (`BF`, `SF`, `CR`, `PW`), таймингов передачи (`PAUSE` — пауза между пакетами, `ACKT` — ожидание подтверждения), управления ACK (`ACK` с параметрами `v` или `toggle`), отправки маяка `BCN`, тестовой передачи `TXL`, а также GET‑вариант `TX` для совместимости с веб-клиентом. Для работы с хранилищем используются команды `KEYSTATE`, `KEYGEN`, `KEYRESTORE`, `KEYTRANSFER SEND`, `KEYTRANSFER RECEIVE` (для обратной совместимости поддерживаются и `KEYSEND`/`KEYRECV`), возвращающие состояние в формате JSON.
- Команда `RSTS` принимает параметр `full=1` и возвращает JSON со сводкой по элементам (`name`, `type`, `len`, `text`, `hex`); этот ответ использует веб-интерфейс, чтобы показать текст входящих сообщений и передать данные в чат.

## Хранилище ключей
На ПК и ESP32 ключи хранятся в файле `key_storage/key.stkey`. На ESP32 файл размещается в `SPIFFS` в каталоге `/keys`, на ПК — в директории `key_storage/`. Запись содержит:

- корневую пару ключей Curve25519 (приватный и публичный);
- текущий симметричный ключ AES-CCM длиной 16 байт;
- соль для генерации нонсов и последний публичный ключ удалённой стороны.

При генерации нового ключа предыдущая версия переименовывается в `key.stkey.old`. Если резервная копия уже существует, она удаляется перед созданием новой.

### Генерация и передача ключей
1. На вкладке **Security** отображаются тип активного ключа (`LOCAL` или `EXTERNAL`), четырёхсимвольный идентификатор (первые байты SHA-256 симметричного ключа), публичный корневой ключ и наличие резервной копии.
2. Кнопка **KEYGEN** выполняет генерацию корневой пары Curve25519 на устройстве, сохраняет новый файл `key.stkey` и автоматически обновляет используемый AES-ключ в модулях `TxModule` и `RxModule`.
3. **KEY RESTORE** возвращает файл `key.stkey` из резервной копии `key.stkey.old` (если она есть) и перечитывает ключи в модулях.
4. **KEYTRANSFER SEND** формирует специальный LoRa-кадр с публичным корневым ключом устройства, шифрует его выделенным корневым AES-ключом и отправляет партнёру. В веб-интерфейсе ключ дополнительно копируется в буфер обмена (при поддержке API браузера).
5. **KEYTRANSFER RECEIVE** ожидает защищённый кадр по LoRa, расшифровывает его тем же корневым ключом, применяет переданный публичный ключ (ECDH) и помечает полученный симметричный ключ как внешний; при тайм-ауте команда возвращает ошибку. Во время ожидания кнопка в веб-интерфейсе переходит в мигающий режим, наглядно показывая активное прослушивание эфира.

### Тест шифрования ENCT
На вкладке **Security** отображается отдельный блок с результатами команды `ENCT`: исходные данные, шифртекст, тег и nonce в шестнадцатеричном виде, а также расшифрованная строка.
Данные берутся из JSON-ответа прошивки и синхронно выводятся в журнал Debug, поэтому легко увидеть, какие значения использовались при проверке алгоритма.

### Специальный корневой ключ передачи
Для обмена сообщениями `KEYTRANSFER` используется отдельный статический AES-ключ, зашитый в модуле `libs/key_transfer`. Он служит только для шифрования LoRa-кадров с публичными ключами и не влияет на рабочий симметричный ключ шифрования трафика.

## API
### MessageBuffer
- `MessageBuffer(size_t capacity)` — создать буфер с максимальным количеством сообщений.
- `uint32_t enqueue(const uint8_t* data, size_t len)` — добавляет сообщение в буфер, при переполнении возвращает `0`.
- `size_t freeSlots() const` — получить число свободных слотов в очереди.
- `bool dropLast()` — удалить последнее сообщение (используется для отката).
- `bool hasPending() const` — проверяет наличие сообщений.
- `bool pop(uint32_t& id, std::vector<uint8_t>& out)` — извлекает сообщение и его идентификатор.

### ReceivedBuffer
- `std::string pushRaw(uint32_t id, uint32_t part, const uint8_t* data, size_t len)` — сохранить сырой пакет и получить имя вида `R-000000|номер`.
- `std::string pushSplit(uint32_t id, const uint8_t* data, size_t len)` — сохранить объединённые данные с именем `SP-00000`.
- `std::string pushReady(uint32_t id, const uint8_t* data, size_t len)` — сохранить готовые данные `GO-00000`.
- `Item::name` хранит заранее сформированную подпись элемента, поэтому повторное обращение к имени не требует форматирования.
- `bool popRaw(Item& out)`, `bool popSplit(Item& out)`, `bool popReady(Item& out)` — извлечь данные соответствующего типа.
- `std::vector<std::string> list(size_t count)` — получить имена первых элементов (не более `count`).
- `std::vector<SnapshotEntry> snapshot(size_t count)` — получить копию первых элементов с типом очереди; структура `SnapshotEntry` содержит сам `Item` и перечисление `Kind`, что позволяет формировать JSON-ответ для команды `RSTS`.

### PacketSplitter
- `PacketSplitter(PayloadMode mode, size_t custom = 0)` — создать делитель с выбранным режимом или произвольным размером блока.
- `void setMode(PayloadMode mode)` — сменить режим.
- `void setCustomSize(size_t custom)` — задать произвольный размер части в байтах.
- `uint32_t splitAndEnqueue(MessageBuffer& buf, const uint8_t* data, size_t len)` — разбить данные на части и занести их в буфер с предварительной проверкой свободных слотов и откатом при ошибке.

### PacketGatherer
- `PacketGatherer(PayloadMode mode, size_t custom = 0)` — создать собиратель с режимом или произвольным размером блока.
- `void reset()` — сбросить накопленные данные.
- `void add(const uint8_t* data, size_t len)` — добавить очередную часть.
- `bool isComplete() const` — проверить завершение сбора (актуально при фиксированном размере блока).
- `const std::vector<uint8_t>& get() const` — получить готовое сообщение.

### FrameHeader
- `bool encode(uint8_t* out, size_t out_len, const uint8_t* payload, size_t payload_len)` — записать заголовок в буфер и подсчитать CRC.
- `static bool decode(const uint8_t* data, size_t len, FrameHeader& out)` — разобрать заголовок из буфера и проверить CRC.

### TxModule
- `TxModule(IRadio& radio, const std::array<size_t,4>& capacities, PayloadMode mode)` — инициализация модуля с четырьмя очередями QoS.
- `void setPayloadMode(PayloadMode mode)` — сменить режим размера пакета.
- `uint32_t queue(const uint8_t* data, size_t len, uint8_t qos = 0)` — поместить сообщение в очередь выбранного класса QoS.
- `void loop()` — отправить первое сообщение, если оно есть.
- `void setSendPause(uint32_t pause_ms)` — задать паузу между отправками в миллисекундах.
- Во время паузы и ожидания подтверждения модуль принудительно переводит радиоинтерфейс в режим приёма.
- После `rs255223::encode()` выполняется `byte_interleaver::interleave()`, затем `conv_codec::encodeBits()`,
  при необходимости `bit_interleaver::interleave()` и `scrambler::scramble()`.

### RxModule
- `void setCallback(RxModule::Callback cb)` — установить обработчик входящих данных.
- `void onReceive(const uint8_t* data, size_t len)` — принять кадр, проверить CRC и передать полезные данные обработчику.
- `void setBuffer(ReceivedBuffer* buf)` — привязать буфер для автоматического сохранения готовых сообщений.
- Внутренние буферы кадра, полезной нагрузки и результата переиспользуются между вызовами, что снижает количество выделений и копирования.
- Перед декодером RS выполняется обратная цепочка: `scrambler::descramble()`,
  `bit_interleaver::deinterleave()`, `conv_codec::viterbiDecode()`,
  затем `byte_interleaver::deinterleave()`.

### RadioSX1262
  - `bool begin()` — инициализация радиомодуля с автоматическим возвратом параметров к значениям по умолчанию.
- `void send(const uint8_t* data, size_t len)` — отправка пакета.
- `bool ping(const uint8_t* data, size_t len, uint8_t* response, size_t responseCapacity, size_t& receivedLen, uint32_t timeoutUs, uint32_t& elapsedUs)` — отправка служебного пакета и ожидание эха с возвратом параметров приёма.
- `void loop()` — обработка готовности пакета и вызов колбэка в основном цикле.
- `void setReceiveCallback(IRadio::RxCallback cb)` — регистрация обработчика приёма.
- `float getLastSnr() const` — получить SNR последнего принятого пакета.
- `float getLastRssi() const` — получить RSSI последнего принятого пакета.
- `uint8_t randomByte()` — получить случайный байт от радиомодуля.
- `bool setBank(ChannelBank bank)` — выбрать банк каналов (`EAST`, `WEST`, `TEST`, `ALL`).
- `bool setChannel(uint8_t ch)` — выбрать номер канала 0…N-1 и установить частоту приёма.
- `bool setBandwidth(float bw)` — задать ширину полосы в кГц.
- `bool setSpreadingFactor(int sf)` — указать фактор расширения 5…12.
- `bool setCodingRate(int cr)` — задать коэффициент кодирования 5…8.
- `bool setPower(uint8_t preset)` — установить уровень мощности из таблицы (-5…22 дБм).
- `void sendBeacon()` — отправить служебный пакет-маяк.
- `ChannelBank getBank() const`, `uint8_t getChannel() const`, `uint16_t getBankSize() const`, `float getBandwidth() const`, `int getSpreadingFactor() const`, `int getCodingRate() const`, `int getPower() const`, `float getRxFrequency() const`, `float getTxFrequency() const` — получить текущие параметры.
- `static uint16_t bankSize(ChannelBank bank)` — количество каналов в указанном банке.
- `static float bankRx(ChannelBank bank, uint16_t ch)` — частота приёма канала в банке.
 - `static float bankTx(ChannelBank bank, uint16_t ch)` — частота передачи канала в банке.
  - `bool resetToDefaults()` — вернуть параметры радиомодуля к значениям по умолчанию.
  - Значения параметров по умолчанию (размер блока для `PacketGatherer`, пауза между отправками и т.д.) заданы в файле `default_settings.h`.

### SerialProgramCollector
- `void resetBuffer()` — очистить буфер и начать новый сбор.
- `bool appendToBuffer(const String& line)` — добавить строку в общий буфер с проверкой переполнения.

### TextConverter
- `std::vector<uint8_t> utf8ToCp1251(const std::string& in)` — преобразует UTF-8 строку в байты CP1251.
- `std::string cp1251ToUtf8(const std::vector<uint8_t>& data)` — преобразует массив байтов CP1251 в UTF-8 строку (неизвестные символы заменяются на `?`).

### rs255223
- `void encode(const uint8_t* in, uint8_t* out)` — кодирует 223 байта в 255 байт.
- `bool decode(const uint8_t* in, uint8_t* out)` — декодирует 255 байт и возвращает 223 байта данных.

### conv_codec
- `void encodeBits(const uint8_t* in, size_t len, std::vector<uint8_t>& out)` — свёрточное кодирование (R=1/2).
- `bool viterbiDecode(const uint8_t* in, size_t len, std::vector<uint8_t>& out)` — декодирование алгоритмом Витерби.

### bit_interleaver
- `void interleave(uint8_t* buf, size_t len)` — битовое перемежение.
- `void deinterleave(uint8_t* buf, size_t len)` — обратное битовое перемежение.

### KeyLoader
- `std::array<uint8_t,16> KeyLoader::loadKey()` — считывает активный симметричный ключ AES-CCM из файла `key.stkey` (при отсутствии создаёт запись на основе значения по умолчанию).
- `bool KeyLoader::saveKey(const std::array<uint8_t,16>& key, KeyOrigin origin, const std::array<uint8_t,32>* peer, uint32_t salt)` — сохраняет симметричный ключ, помечая его происхождение и (опционально) публичный ключ собеседника.
- `bool KeyLoader::generateLocalKey(KeyRecord* out = nullptr)` — генерирует новую пару Curve25519, вычисляет локальный симметричный ключ, обновляет файл `key.stkey` и резервную копию.
- `bool KeyLoader::restorePreviousKey(KeyRecord* out = nullptr)` — восстанавливает файл `key.stkey` из `key.stkey.old`, если резервная копия существует.
- `bool KeyLoader::applyRemotePublic(const std::array<uint8_t,32>& remote)` — вычисляет общий секрет по Curve25519, формирует симметричный ключ и сохраняет его как внешний.
- `KeyState KeyLoader::getState()` — возвращает структуру со сведениями о текущем ключе (тип, идентификатор, публичные ключи, наличие резервной копии).
- `std::array<uint8_t,12> KeyLoader::makeNonce(uint32_t msg_id, uint16_t frag_idx)` — формирует нонс AES-CCM на основе идентификатора сообщения и индекса фрагмента.

### AES-CCM

- `bool encrypt_ccm(const uint8_t* key, size_t key_len, const uint8_t* nonce, size_t nonce_len, const uint8_t* aad, size_t aad_len, const uint8_t* input, size_t input_len, std::vector<uint8_t>& output, std::vector<uint8_t>& tag, size_t tag_len)` — шифрует данные и формирует тег.
- `bool decrypt_ccm(const uint8_t* key, size_t key_len, const uint8_t* nonce, size_t nonce_len, const uint8_t* aad, size_t aad_len, const uint8_t* input, size_t input_len, const uint8_t* tag, size_t tag_len, std::vector<uint8_t>& output)` — проверяет тег и расшифровывает данные.

## Команда ENCT

Тестовая команда для проверки шифрования AES-CCM. Формирует короткое сообщение,
зашифровывает его, расшифровывает обратно и выводит результат сравнения.

Пример запуска теста на ПК:

```
g++ -I. tests/test_enct.cpp libs_includes.cpp -std=c++17 && ./a.out
```

В `serial_radio_control.ino` команду можно вызвать через Serial:

```
ENCT
ENCT: успех
```

## Команды Serial

- `BANK <e|w|t|a>` — выбрать банк каналов.
- `CH <номер>` — переключить канал в пределах текущего банка.
- `PI` — отправляет 5-байтовый пинг с XOR-идентификатором и адресом, затем ожидает эхо `PING_WAIT_MS` миллисекунд. При совпадении пакета выводит `PI: RSSI=<дБм> SNR=<дБ> distance≈<км> time=<мс>`, при отсутствии ответа — `PI: timeout`.
- `SEAR` — последовательно пингует все каналы. Для каждого канала ожидание ответа начинается только после подтверждённой отправки: выводится `SEAR <канал>: RSSI=<дБм> SNR=<дБ>` либо `SEAR <канал>: timeout`.
- `ACK [0|1]` — включить или выключить автоматическую отправку подтверждений.
- `KEYTRANSFER SEND` — отправить публичный корневой ключ по LoRa через специальный корневой AES-ключ.
- `KEYTRANSFER RECEIVE` — ожидать защищённый кадр с публичным ключом и применить его при успешном приёме.

## Пример последовательности вызовов
```
// Передача
шифрование -> PacketSplitter (223 байта) -> rs255223::encode ->
byte_interleaver::interleave -> conv_codec::encodeBits ->
bit_interleaver::interleave -> scrambler::scramble -> отправка

// Приём
scrambler::descramble -> bit_interleaver::deinterleave ->
conv_codec::viterbiDecode -> byte_interleaver::deinterleave ->
rs255223::decode -> PacketGatherer -> обработка сообщения
```

## Что реализовано
- Базовая отправка и приём сообщений.
- Передача публичного корневого ключа по LoRa командами KEYTRANSFER SEND/RECEIVE с шифрованием корневым AES-ключом.
- Очереди сообщений по классам QoS с приоритетной обработкой.
- Делитель и собиратель пакетов с тремя режимами размера payload.
- Буфер принятых сообщений с форматами `R/SP/GO`.
- Реализована настройка радиомодуля SX1262 и методы отправки/приёма.
- Обработка входящих пакетов через флаг `packetReady` и метод `loop()`.
- Приём строк по Serial и объединение их в буфер с лимитом `DefaultSettings::SERIAL_BUFFER_LIMIT` (по умолчанию 500 КБ).
- Добавлен заголовок кадра с контролем CRC и вставкой пилотов при передаче.
- Настройка полосы, фактора расширения, коэффициента кодирования и банка каналов с разнесением частот приёма и передачи через Serial.
- Тестовая отправка пакета через Serial с автоматическим переключением частоты TX.
- Настройка паузы между отправками пакетов в TxModule.
- Маркировка частей случайным идентификатором `[ID|номер]` и журнал статусов `ERR/PROG/GO` с выводом командой `STS`.
- Добавлено кодирование и декодирование RS(255,223) с байтовым интерливингом,\
  которое можно отключить флагом `DefaultSettings::USE_RS` (по умолчанию выключено).
- Формирование 223-байтовых блоков через `PacketSplitter` перед RS-кодированием и сборка их в `RxModule` с помощью `PacketGatherer`.
- Внедрены свёрточное кодирование и Viterbi-декодирование,
  опциональный битовый интерливинг и скремблирование кадра перед передачей.
- Проверка длины фрагмента и разделение при превышении лимита (245 байт аппаратного буфера SX1262).
- Сброс параметров радиомодуля к значениям по умолчанию.
- Автоматическая установка этих параметров при запуске.
- Настройка мощности и команда INFO для отображения текущих параметров.
- Отправка служебного маяка для поиска устройств.
- Конвертация UTF-8 текста в CP1251 для команды TX.
- Отправка большого пакета произвольного размера командой TXL.
- Реализована команда PI для пинга с выводом RSSI и SNR.
- Добавлена команда SEAR для последовательного пинга всех каналов с выводом RSSI и SNR.
- Добавлены методы `getLastRssi()` и `getLastSnr()` в `RadioSX1262`.
- Добавлен метод `randomByte()` в `RadioSX1262`.
- Добавлен банк частот `ALL` и команда выбора этого банка через Serial.
- Введена константа `PING_WAIT_MS`, задающая время ожидания ответа на пинг.
- Пример `serial_radio_control.ino` использует 160-слотовые очереди, что позволяет хранить несколько сообщений по 5000 байт.
- Файл `default_settings.h` с параметрами радиомодуля, размером блока `PacketGatherer`,
  ёмкостью очередей, флагами `USE_RS` и `USE_ACK`, паузой между отправками и константой `PING_WAIT_MS` для ожидания ответа пинга.
- Реализованы подтверждения `ACK`, управляемые командой `ACK` и флагом `DefaultSettings::USE_ACK`.
- Добавлен комплексный тест, проверяющий полный цикл обработки без реального радиоканала. Запуск: `g++ -I. -I.. tests/test_processing_without_send.cpp tx_module.cpp rx_module.cpp message_buffer.cpp libs_includes.cpp -std=c++17 && ./a.out`.
- Базовые тесты для буфера сообщений, делителя пакетов и формирования кадров.
- Добавлен тест совместимости `RxModule` с внешним `ReceivedBuffer`,
  подтверждающий корректное отображение готовых сообщений в буфере.
- Загрузка ключа шифрования из памяти NVS (или файла `key_storage/key.bin` на ПК) с использованием значения по умолчанию при отсутствии сохранённого ключа.
- Реализованы функции `encrypt_ccm()` и `decrypt_ccm()` для шифрования AES-CCM.
- Внедрено шифрование фрагментов через `encrypt_ccm()` и их дешифрование в `RxModule`.
- Добавлен лёгкий интерфейс Codex с тремя панелями (Запрос, Редактор, Результат) и стримингом ответа.
- Добавлено видимое выделение фокуса для ссылок и кнопок в веб-интерфейсе.
- Реализована точка доступа Wi-Fi `sat_ap` и минимальный HTTP-сервер для подключения веб-интерфейса.
- Точка доступа использует статический IP `192.168.4.1`, что позволяет открыть веб-интерфейс по адресу `http://192.168.4.1/`.
- HTTP-сервер теперь отдаёт страницы веб-интерфейса (`index.html`, `style.css`, `script.js`, `libs/sha256.js`) прямо из прошивки.
- Добавлен HTTP-эндпоинт `/api/tx` и кнопка «Отправить по радио» для отправки текстовых сообщений.
- Расширен HTTP-интерфейс для команд `BF`, `SF`, `CR`, `PW`, `ACK`, `BCN`, `TXL`, `TX` и добавлено отображение состояния ACK и служебных кнопок в веб-интерфейсе.
- Команда `INFO` дополнена выводом текущего состояния ACK для проверки конфигурации.
- Вкладка Settings веб-интерфейса получила переключатель ACK с синхронизацией состояния устройства и общей функцией `withAckLock()` для блокировки элементов на время запросов.
- Чат поддерживает форматирование многострочных ответов, команды со слешем, отправку сообщений через `/TX`, а также сохранение истории и быстрый запуск тестовой передачи `TXL`.

## Что осталось сделать
  - Реализовать обмен ключами через сеть взамен заглушек.
  - Расширить управление радиомодулем (дополнительные команды и возможности).
  - Доработать кодирование ошибок и дополнительные механизмы шифрования.
  - Реализовать обработку пилотов в RxPipeline (`updatePhaseFromPilot`).
  - Вернуть расширенные возможности исходного проекта по мере необходимости.
  - Уточнить формат пакетов (нумерация частей, контроль целостности) для надёжной сборки.
  - Интегрировать `ReceivedBuffer` в цепочку обработки и удаление исходных пакетов после преобразования.
  - Завершить интеграцию RS-кода для сообщений произвольной длины.
  - Передавать точную длину последнего фрагмента при сборке сообщений.
  - Добавить сохранение собранной программы и расширенную обработку команд завершения.
  - Покрыть тестами приём и обработку пилотов.
  - Реализовать реальные процедуры отправки и приёма ключей вместо заглушек.
  - Реализовать поддержку других кодировок и символов в конвертере текста.
  - Внедрить планировщик WFQ для классов QoS.
  - Добавить тесты и настройку для битового интерливинга и свёрточного кодека.
  - Реализовать очистку и долговременное хранение журнала статусов.

