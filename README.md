# Минимальный модуль передачи и приёма

В форке оставлены только базовые компоненты:

- `MessageBuffer` — простой буфер сообщений с ограничением по размеру.
- `ReceivedBuffer` — буфер принятых сообщений с разделением на raw/SP/GO форматы.
- `PacketSplitter` — делитель пакетов с тремя режимами размера полезной нагрузки.
- `PacketGatherer` — собиратель пакетов обратно в сообщение.
- `TxModule` — передача данных через интерфейс `IRadio`.
- `RxModule` — приём данных и передача их в пользовательский колбэк.
- `FrameHeader` — заголовок кадра с функциями `encode()` и `decode()`.
- `IRadio` описан в `radio_interface.h`.
- `RadioSX1262` — конкретная реализация интерфейса на базе модуля SX1262.
- `SerialProgramCollector` — библиотека для приёма строк по Serial и сборки их в один буфер (`libs/serial_program_collector/`).
- `serial_radio_control.ino` — пример настройки банков каналов, BW, SF, CR и мощности через Serial, вывода текущих параметров и отправки тестовых пакетов через `TxModule`, включая команды `TXL` для больших сообщений, `STS <n>` для просмотра журнала, `RSTS <n>` для просмотра содержимого `ReceivedBuffer`, `PI` для пинга и `SEAR` для поиска по всем каналам.
- `TextConverter` — библиотека (`libs/text_converter/`) для преобразования UTF-8 текста в байты CP1251, используемая командой `TX`.
- `rs255223` — библиотека (`libs/rs255223/`) с обёртками `encode()` и `decode()` для кода Рида–Соломона RS(255,223).
- `byte_interleaver` — библиотека (`libs/byte_interleaver/`) с функциями `interleave()` и `deinterleave()` для байтового перемежения.
- `conv_codec` — библиотека (`libs/conv_codec/`) с функциями `encodeBits()` и `viterbiDecode()` для свёрточного кодирования.
- `bit_interleaver` — библиотека (`libs/bit_interleaver/`) с функциями `interleave()` и `deinterleave()` для битового перемежения.
  - `scrambler` — библиотека (`libs/scrambler/`) с функциями `scramble()` и `descramble()` на основе LFSR
  (полином x^16 + x^14 + x^13 + x^11, стартовое значение 0xACE1).
- `SimpleLogger` — библиотека (`libs/simple_logger/`) для записи статусов `ERR/PROG/GO` и вывода их командой `STS`. Повторная запись с одинаковым префиксом перезаписывает предыдущий статус.
- Для отладочных сообщений предусмотрен флаг `DefaultSettings::DEBUG` и уровни журналирования `DefaultSettings::LOG_LEVEL`. Доступны макросы `LOG_ERROR`, `LOG_WARN`, `LOG_INFO`, `DEBUG_LOG` и их варианты с выводом значения (`*_VAL`) для фильтрации лишнего спама. Последовательные одинаковые строки автоматически подавляются, а на Arduino вывод дополнительно сбрасывается через `Serial.flush()`.

Все сторонние библиотеки расположены в каталоге `libs/`.
Для корректной сборки в Arduino добавлен вспомогательный файл `libs_includes.cpp`,
который явно подключает реализации библиотек.

## Веб-интерфейс
В каталоге `web/` расположен интерфейс с пятью вкладками **Chat**, **Channels/Ping**, **Settings**, **Security** и **Debug**, оформленными в одном стиле.
Чат показывает историю сообщений пузырьками и позволяет отправлять команды устройству.
Под блоком команд размещён монитор принятых сообщений: список имён `GO-xxxxx` подгружается командой `RSTS`, поддерживает автообновление, лимит по количеству, подсветку новых элементов и копирование имени в буфер обмена одним кликом.
Вкладка каналов строит таблицу частот из активного банка и поддерживает пинг/поиск.
Из таблицы убраны столбцы BW, SF, CR и PW, остаются только частоты, RSSI, SNR, статус и результат сканирования.
Текущий канал подсвечивается, а строкам назначаются классы `busy`, `free` или `unknown` в зависимости от статуса.
При клике по строке справа появляется карточка с текущими измерениями и справочными сведениями (System, Band Plan, Purpose), подгружаемыми из `web/libs/freq-info.csv`.
Кнопка **Search** запускает последовательный пинг каждого канала активного банка: текущая строка выделяется голубым (`scanning`), ответившие каналы — зелёным (`signal`), пакеты с ошибкой CRC — оранжевым (`crc-error`), каналы без ответа — серым (`no-response`). Повторное нажатие останавливает цикл. Результаты можно выгрузить в CSV с дополнительным столбцом `scan_state`.
Для корректного обновления подписи состояния и таблицы во время сканирования добавлена вспомогательная функция `uiYield()` в `web/script.js`, которая уступает управление циклу отрисовки через `requestAnimationFrame` (при его отсутствии используется `setTimeout`).
Для разбора ответов и подсветки строк в `web/script.js` добавлены вспомогательные функции `detectScanState()`, `applyPingToEntry()` и `setChannelScanState()`.
В разделе Settings доступны элементы управления ACK, BANK, BF, CH, CR, PW и SF с заранее заданными параметрами; канал и мощность выбираются из выпадающих списков, параметр STS удалён. Выбор канала применяет настройку немедленно и тут же обновляет отображение текущего состояния.
Вкладка Debug выводит отладочные сообщения.
После подключения к точке доступа страница открывается по адресу `http://192.168.4.1/`.
Файл `web/web_content.h` содержит строки `index.html`, `style.css`, `script.js` и библиотеку `libs/sha256.js`, подключённые напрямую без конвертации в массивы.
Отдельный файл `index.html` удалён, вся разметка хранится только в `web_content.h`.
Логика работы интерфейса находится в `web/script.js` и отвечает за переключение вкладок, отправку команд и сохранение настроек.
Для расчёта хеша ключа на вкладке Security добавлена чистая JS‑реализация SHA-256 (`web/libs/sha256.js`), позволяющая работать в HTTP‑среде без WebCrypto.
Чат дополнен блоком состояния ACK: сам индикатор стал переключателем режима, рядом оставлена компактная кнопка ручного обновления.
Кнопки `BCN` и `ENCT`, а также блок отправки `TXL` позволяют вызывать служебные команды без ввода через текстовое поле.
Ввод команд через `/` поддерживает передачу аргументов (`/ACK 0`, `/STS 5`, `/TX Привет`) и автоматически сохраняет историю в `localStorage`.

### HTTP API
- `POST /api/tx` — принимает текст в теле запроса и отправляет его через `TxModule`.
- В веб-интерфейсе добавлена кнопка «Отправить по радио», использующая этот эндпоинт.
- `GET /cmd?c=<CMD>` — выполнение команды (`PI`, `SEAR`, `BANK`, `CH`, `CHLIST`, `STS`, `RSTS`, `INFO`). Параметры передаются через `v` или `bank`.
- `GET /api/cmd?cmd=<CMD>` — совместимый адрес для тех же команд.
- Через HTTP доступны команды настройки радиопараметров (`BF`, `SF`, `CR`, `PW`), управления ACK (`ACK` с параметрами `v` или `toggle`), отправки маяка `BCN`, тестовой передачи `TXL`, а также GET‑вариант `TX` для совместимости с веб-клиентом.

## Хранилище ключей
На ESP32 ключ сохраняется во внутренней памяти NVS и считывается функцией `KeyLoader::loadKey()`.
Запись нового ключа выполняется через `KeyLoader::saveKey()`.
При запуске на ПК используется файл `key_storage/key.bin`; при его отсутствии применяется `DefaultSettings::DEFAULT_KEY`.

### Генерация и передача ключей
1. На вкладке **Security** отображается текущее состояние ключа: `LOCAL` при использовании встроенного значения либо первые четыре символа хеша SHA-256 сохранённого ключа.
2. Кнопка **KEYGEN** генерирует новый случайный 16-байтовый ключ и сохраняет его в `localStorage`.
3. **KEYTRANSFER SEND** — заглушка для отправки ключа на другое устройство.
4. **KEYTRANSFER RECEIVE** — заглушка для приёма ключа от другого устройства.

## API
### MessageBuffer
- `MessageBuffer(size_t capacity)` — создать буфер с максимальным количеством сообщений.
- `uint32_t enqueue(const uint8_t* data, size_t len)` — добавляет сообщение в буфер, при переполнении возвращает `0`.
- `size_t freeSlots() const` — получить число свободных слотов в очереди.
- `bool dropLast()` — удалить последнее сообщение (используется для отката).
- `bool hasPending() const` — проверяет наличие сообщений.
- `bool pop(uint32_t& id, std::vector<uint8_t>& out)` — извлекает сообщение и его идентификатор.

### ReceivedBuffer
- `std::string pushRaw(uint32_t id, uint32_t part, const uint8_t* data, size_t len)` — сохранить сырой пакет и получить имя вида `R-000000|номер`.
- `std::string pushSplit(uint32_t id, const uint8_t* data, size_t len)` — сохранить объединённые данные с именем `SP-00000`.
- `std::string pushReady(uint32_t id, const uint8_t* data, size_t len)` — сохранить готовые данные `GO-00000`.
- `Item::name` хранит заранее сформированную подпись элемента, поэтому повторное обращение к имени не требует форматирования.
- `bool popRaw(Item& out)`, `bool popSplit(Item& out)`, `bool popReady(Item& out)` — извлечь данные соответствующего типа.
- `std::vector<std::string> list(size_t count)` — получить имена первых элементов (не более `count`).

### PacketSplitter
- `PacketSplitter(PayloadMode mode, size_t custom = 0)` — создать делитель с выбранным режимом или произвольным размером блока.
- `void setMode(PayloadMode mode)` — сменить режим.
- `void setCustomSize(size_t custom)` — задать произвольный размер части в байтах.
- `uint32_t splitAndEnqueue(MessageBuffer& buf, const uint8_t* data, size_t len)` — разбить данные на части и занести их в буфер с предварительной проверкой свободных слотов и откатом при ошибке.

### PacketGatherer
- `PacketGatherer(PayloadMode mode, size_t custom = 0)` — создать собиратель с режимом или произвольным размером блока.
- `void reset()` — сбросить накопленные данные.
- `void add(const uint8_t* data, size_t len)` — добавить очередную часть.
- `bool isComplete() const` — проверить завершение сбора (актуально при фиксированном размере блока).
- `const std::vector<uint8_t>& get() const` — получить готовое сообщение.

### FrameHeader
- `bool encode(uint8_t* out, size_t out_len, const uint8_t* payload, size_t payload_len)` — записать заголовок в буфер и подсчитать CRC.
- `static bool decode(const uint8_t* data, size_t len, FrameHeader& out)` — разобрать заголовок из буфера и проверить CRC.

### TxModule
- `TxModule(IRadio& radio, const std::array<size_t,4>& capacities, PayloadMode mode)` — инициализация модуля с четырьмя очередями QoS.
- `void setPayloadMode(PayloadMode mode)` — сменить режим размера пакета.
- `uint32_t queue(const uint8_t* data, size_t len, uint8_t qos = 0)` — поместить сообщение в очередь выбранного класса QoS.
- `void loop()` — отправить первое сообщение, если оно есть.
- `void setSendPause(uint32_t pause_ms)` — задать паузу между отправками в миллисекундах.
- После `rs255223::encode()` выполняется `byte_interleaver::interleave()`, затем `conv_codec::encodeBits()`,
  при необходимости `bit_interleaver::interleave()` и `scrambler::scramble()`.

### RxModule
- `void setCallback(RxModule::Callback cb)` — установить обработчик входящих данных.
- `void onReceive(const uint8_t* data, size_t len)` — принять кадр, проверить CRC и передать полезные данные обработчику.
- `void setBuffer(ReceivedBuffer* buf)` — привязать буфер для автоматического сохранения готовых сообщений.
- Внутренние буферы кадра, полезной нагрузки и результата переиспользуются между вызовами, что снижает количество выделений и копирования.
- Перед декодером RS выполняется обратная цепочка: `scrambler::descramble()`,
  `bit_interleaver::deinterleave()`, `conv_codec::viterbiDecode()`,
  затем `byte_interleaver::deinterleave()`.

### RadioSX1262
  - `bool begin()` — инициализация радиомодуля с автоматическим возвратом параметров к значениям по умолчанию.
- `void send(const uint8_t* data, size_t len)` — отправка пакета.
- `bool ping(const uint8_t* data, size_t len, uint8_t* response, size_t responseCapacity, size_t& receivedLen, uint32_t timeoutUs, uint32_t& elapsedUs)` — отправка служебного пакета и ожидание эха с возвратом параметров приёма.
- `void loop()` — обработка готовности пакета и вызов колбэка в основном цикле.
- `void setReceiveCallback(IRadio::RxCallback cb)` — регистрация обработчика приёма.
- `float getLastSnr() const` — получить SNR последнего принятого пакета.
- `float getLastRssi() const` — получить RSSI последнего принятого пакета.
- `uint8_t randomByte()` — получить случайный байт от радиомодуля.
- `bool setBank(ChannelBank bank)` — выбрать банк каналов (`EAST`, `WEST`, `TEST`, `ALL`).
- `bool setChannel(uint8_t ch)` — выбрать номер канала 0…N-1 и установить частоту приёма.
- `bool setBandwidth(float bw)` — задать ширину полосы в кГц.
- `bool setSpreadingFactor(int sf)` — указать фактор расширения 5…12.
- `bool setCodingRate(int cr)` — задать коэффициент кодирования 5…8.
- `bool setPower(uint8_t preset)` — установить уровень мощности из таблицы (-5…22 дБм).
- `void sendBeacon()` — отправить служебный пакет-маяк.
- `ChannelBank getBank() const`, `uint8_t getChannel() const`, `uint16_t getBankSize() const`, `float getBandwidth() const`, `int getSpreadingFactor() const`, `int getCodingRate() const`, `int getPower() const`, `float getRxFrequency() const`, `float getTxFrequency() const` — получить текущие параметры.
- `static uint16_t bankSize(ChannelBank bank)` — количество каналов в указанном банке.
- `static float bankRx(ChannelBank bank, uint16_t ch)` — частота приёма канала в банке.
 - `static float bankTx(ChannelBank bank, uint16_t ch)` — частота передачи канала в банке.
  - `bool resetToDefaults()` — вернуть параметры радиомодуля к значениям по умолчанию.
  - Значения параметров по умолчанию (размер блока для `PacketGatherer`, пауза между отправками и т.д.) заданы в файле `default_settings.h`.

### SerialProgramCollector
- `void resetBuffer()` — очистить буфер и начать новый сбор.
- `bool appendToBuffer(const String& line)` — добавить строку в общий буфер с проверкой переполнения.

### TextConverter
- `std::vector<uint8_t> utf8ToCp1251(const std::string& in)` — преобразует UTF-8 строку в байты CP1251.

### rs255223
- `void encode(const uint8_t* in, uint8_t* out)` — кодирует 223 байта в 255 байт.
- `bool decode(const uint8_t* in, uint8_t* out)` — декодирует 255 байт и возвращает 223 байта данных.

### conv_codec
- `void encodeBits(const uint8_t* in, size_t len, std::vector<uint8_t>& out)` — свёрточное кодирование (R=1/2).
- `bool viterbiDecode(const uint8_t* in, size_t len, std::vector<uint8_t>& out)` — декодирование алгоритмом Витерби.

### bit_interleaver
- `void interleave(uint8_t* buf, size_t len)` — битовое перемежение.
- `void deinterleave(uint8_t* buf, size_t len)` — обратное битовое перемежение.

### KeyLoader
- `std::array<uint8_t,16> KeyLoader::loadKey()` — считывает ключ из памяти (NVS на ESP32 или файл `key_storage/key.bin` на ПК) и возвращает значение по умолчанию при отсутствии сохранённого ключа.
- `bool KeyLoader::saveKey(const std::array<uint8_t,16>& key)` — сохраняет ключ в память (NVS или файл).

### AES-CCM

- `bool encrypt_ccm(const uint8_t* key, size_t key_len, const uint8_t* nonce, size_t nonce_len, const uint8_t* aad, size_t aad_len, const uint8_t* input, size_t input_len, std::vector<uint8_t>& output, std::vector<uint8_t>& tag, size_t tag_len)` — шифрует данные и формирует тег.
- `bool decrypt_ccm(const uint8_t* key, size_t key_len, const uint8_t* nonce, size_t nonce_len, const uint8_t* aad, size_t aad_len, const uint8_t* input, size_t input_len, const uint8_t* tag, size_t tag_len, std::vector<uint8_t>& output)` — проверяет тег и расшифровывает данные.

## Команда ENCT

Тестовая команда для проверки шифрования AES-CCM. Формирует короткое сообщение,
зашифровывает его, расшифровывает обратно и выводит результат сравнения.

Пример запуска теста на ПК:

```
g++ -I. tests/test_enct.cpp libs_includes.cpp -std=c++17 && ./a.out
```

В `serial_radio_control.ino` команду можно вызвать через Serial:

```
ENCT
ENCT: успех
```

## Команды Serial

- `BANK <e|w|t|a>` — выбрать банк каналов.
- `CH <номер>` — переключить канал в пределах текущего банка.
- `PI` — отправляет 5-байтовый пинг с XOR-идентификатором и адресом, затем ожидает эхо `PING_WAIT_MS` миллисекунд. При совпадении пакета выводит `PI: RSSI=<дБм> SNR=<дБ> distance≈<км> time=<мс>`, при отсутствии ответа — `PI: timeout`.
- `SEAR` — последовательно пингует все каналы. Для каждого канала ожидание ответа начинается только после подтверждённой отправки: выводится `SEAR <канал>: RSSI=<дБм> SNR=<дБ>` либо `SEAR <канал>: timeout`.
- `ACK [0|1]` — включить или выключить автоматическую отправку подтверждений.

## Пример последовательности вызовов
```
// Передача
шифрование -> PacketSplitter (223 байта) -> rs255223::encode ->
byte_interleaver::interleave -> conv_codec::encodeBits ->
bit_interleaver::interleave -> scrambler::scramble -> отправка

// Приём
scrambler::descramble -> bit_interleaver::deinterleave ->
conv_codec::viterbiDecode -> byte_interleaver::deinterleave ->
rs255223::decode -> PacketGatherer -> обработка сообщения
```

## Что реализовано
- Базовая отправка и приём сообщений.
- Очереди сообщений по классам QoS с приоритетной обработкой.
- Делитель и собиратель пакетов с тремя режимами размера payload.
- Буфер принятых сообщений с форматами `R/SP/GO`.
- Реализована настройка радиомодуля SX1262 и методы отправки/приёма.
- Обработка входящих пакетов через флаг `packetReady` и метод `loop()`.
- Приём строк по Serial и объединение их в буфер с лимитом `DefaultSettings::SERIAL_BUFFER_LIMIT` (по умолчанию 500 КБ).
- Добавлен заголовок кадра с контролем CRC и вставкой пилотов при передаче.
- Настройка полосы, фактора расширения, коэффициента кодирования и банка каналов с разнесением частот приёма и передачи через Serial.
- Тестовая отправка пакета через Serial с автоматическим переключением частоты TX.
- Настройка паузы между отправками пакетов в TxModule.
- Маркировка частей случайным идентификатором `[ID|номер]` и журнал статусов `ERR/PROG/GO` с выводом командой `STS`.
- Добавлено кодирование и декодирование RS(255,223) с байтовым интерливингом,\
  которое можно отключить флагом `DefaultSettings::USE_RS` (по умолчанию выключено).
- Формирование 223-байтовых блоков через `PacketSplitter` перед RS-кодированием и сборка их в `RxModule` с помощью `PacketGatherer`.
- Внедрены свёрточное кодирование и Viterbi-декодирование,
  опциональный битовый интерливинг и скремблирование кадра перед передачей.
- Проверка длины фрагмента и разделение при превышении лимита (245 байт аппаратного буфера SX1262).
- Сброс параметров радиомодуля к значениям по умолчанию.
- Автоматическая установка этих параметров при запуске.
- Настройка мощности и команда INFO для отображения текущих параметров.
- Отправка служебного маяка для поиска устройств.
- Конвертация UTF-8 текста в CP1251 для команды TX.
- Отправка большого пакета произвольного размера командой TXL.
- Реализована команда PI для пинга с выводом RSSI и SNR.
- Добавлена команда SEAR для последовательного пинга всех каналов с выводом RSSI и SNR.
- Добавлены методы `getLastRssi()` и `getLastSnr()` в `RadioSX1262`.
- Добавлен метод `randomByte()` в `RadioSX1262`.
- Добавлен банк частот `ALL` и команда выбора этого банка через Serial.
- Введена константа `PING_WAIT_MS`, задающая время ожидания ответа на пинг.
- Пример `serial_radio_control.ino` использует 160-слотовые очереди, что позволяет хранить несколько сообщений по 5000 байт.
- Файл `default_settings.h` с параметрами радиомодуля, размером блока `PacketGatherer`,
  ёмкостью очередей, флагами `USE_RS` и `USE_ACK`, паузой между отправками и константой `PING_WAIT_MS` для ожидания ответа пинга.
- Реализованы подтверждения `ACK`, управляемые командой `ACK` и флагом `DefaultSettings::USE_ACK`.
- Добавлен комплексный тест, проверяющий полный цикл обработки без реального радиоканала. Запуск: `g++ -I. -I.. tests/test_processing_without_send.cpp tx_module.cpp rx_module.cpp message_buffer.cpp libs_includes.cpp -std=c++17 && ./a.out`.
- Базовые тесты для буфера сообщений, делителя пакетов и формирования кадров.
- Добавлен тест совместимости `RxModule` с внешним `ReceivedBuffer`,
  подтверждающий корректное отображение готовых сообщений в буфере.
- Загрузка ключа шифрования из памяти NVS (или файла `key_storage/key.bin` на ПК) с использованием значения по умолчанию при отсутствии сохранённого ключа.
- Реализованы функции `encrypt_ccm()` и `decrypt_ccm()` для шифрования AES-CCM.
- Внедрено шифрование фрагментов через `encrypt_ccm()` и их дешифрование в `RxModule`.
- Добавлен лёгкий интерфейс Codex с тремя панелями (Запрос, Редактор, Результат) и стримингом ответа.
- Добавлено видимое выделение фокуса для ссылок и кнопок в веб-интерфейсе.
- Реализована точка доступа Wi-Fi `sat_ap` и минимальный HTTP-сервер для подключения веб-интерфейса.
- Точка доступа использует статический IP `192.168.4.1`, что позволяет открыть веб-интерфейс по адресу `http://192.168.4.1/`.
- HTTP-сервер теперь отдаёт страницы веб-интерфейса (`index.html`, `style.css`, `script.js`, `libs/sha256.js`) прямо из прошивки.
- Добавлен HTTP-эндпоинт `/api/tx` и кнопка «Отправить по радио» для отправки текстовых сообщений.
- Расширен HTTP-интерфейс для команд `BF`, `SF`, `CR`, `PW`, `ACK`, `BCN`, `TXL`, `TX` и добавлено отображение состояния ACK и служебных кнопок в веб-интерфейсе.
- Чат поддерживает форматирование многострочных ответов, команды со слешем, отправку сообщений через `/TX`, а также сохранение истории и быстрый запуск тестовой передачи `TXL`.

## Что осталось сделать
  - Реализовать обмен ключами через сеть взамен заглушек.
  - Расширить управление радиомодулем (дополнительные команды и возможности).
  - Доработать кодирование ошибок и дополнительные механизмы шифрования.
  - Реализовать обработку пилотов в RxPipeline (`updatePhaseFromPilot`).
  - Вернуть расширенные возможности исходного проекта по мере необходимости.
  - Уточнить формат пакетов (нумерация частей, контроль целостности) для надёжной сборки.
  - Интегрировать `ReceivedBuffer` в цепочку обработки и удаление исходных пакетов после преобразования.
  - Завершить интеграцию RS-кода для сообщений произвольной длины.
  - Передавать точную длину последнего фрагмента при сборке сообщений.
  - Добавить сохранение собранной программы и расширенную обработку команд завершения.
  - Покрыть тестами приём и обработку пилотов.
  - Реализовать реальные процедуры отправки и приёма ключей вместо заглушек.
  - Реализовать поддержку других кодировок и символов в конвертере текста.
  - Внедрить планировщик WFQ для классов QoS.
  - Добавить тесты и настройку для битового интерливинга и свёрточного кодека.
  - Реализовать очистку и долговременное хранение журнала статусов.

