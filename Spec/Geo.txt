Что нужно докрутить для GEO (только ПО)
1) Тайминги и ARQ под большую задержку

GEO даёт ~600 мс RTT (иногда до 800–1100 мс). Твои текущие таймауты и окно ретраев надо сместить в «секундную» зону. 
Viasat.com
TS2 Space
Reddit

Правки:

config.h:

ACK_TIMEOUT → 1200–1600 мс (старт),

MAX_RETRIES → 6–8,

добавить джиттер ±10–20 % к таймаутам, чтобы избежать синхронных коллизий.

Перейти со stop-and-wait на Selective Repeat ARQ с окном W=4..8.

tx_pipeline.*: вести окно невыплаченных кадров, таймер на каждый.

rx_pipeline.*: буфер out-of-order, выдача вверх по порядку.

frame.h: добавить ack_mask (опционально) для кумулятивного ACK + bitmap (экономит эфир при большом RTT).

Схема экспоненциального бэкоффа на ретраи: 1×, 1.5×, 2×… до лимита.

2) FEC + рандомизация (CCSDS-подобный подслой)

На GEO критичен кодовый выигрыш. Предлагаю вставить подслой синхронизации/кодирования между твоим фреймингом и PHY. Основа — CCSDS: ASM → рандомайзер → FEC (RS⊕Viterbi или LDPC). 
CCSDS
+2
CCSDS
+2

Правки:

Новый модуль ccsds_link.{h,cpp}:

Псевдослучайная рандомизация (как в CCSDS TM).

FEC опции:

базовая: RS(255,223) + Viterbi R=1/2, K=7 (классика, быстрый выигрыш по Eb/N0),

продвинутая: LDPC профили (если у тебя PHY позволяет; оставить выключаемым флагом).

Интерливинг (байтовый) с глубиной 4–16 для борьбы с пакетными ошибками.

Точки врезки:

tx_pipeline.cpp: перед упаковкой в радио-кадр — рандомайзер→FEC→интерливинг.

rx_pipeline.cpp: обратный ход + проверка ASM для грубой синхронизации.

Оставь твой AES-CCM как есть, но FEC обязан идти ПОСЛЕ шифрования, чтобы кодировал уже «белые» данные (иначе FEC ломается на коррелированной структуре). Стандарты так и делают. 
CCSDS

3) Адаптивность к каналу (rate control)

Нужно, чтобы стек сам «подстраивал» длину кадра/повторы/код-рейт под PER/SNR.

radio_adapter.h: добавить методы получения SNR/EbN0 и флаг «lock/quality».

metrics.h: скользящие окна PER, RTT, goodput, Eb/N0.

Контроллер в tx_pipeline.cpp:

если PER > 10 % или Eb/N0 упал — уменьшаем payload_len, включаем больший код-рейт (сильнее FEC), повышаем repeat_count.

если стабильно PER < 1 % — обратно.
Подобная логика — стандарт для ACM/VCM в спутниковых системах. 
ETSI
+1
NTRS
DVB
ITU

4) Фрагментация и защита заголовка

Уже есть frag_idx/frag_cnt — хорошо. Уменьши целевой размер фрагмента до 64–160 B (после FEC он распухнет).

UEP для заголовка: дублируй FrameHeader (или кодируй его более сильным кодом/повтором ×2) + Header CRC отдельным полем. Это резко снижает «фатальные» потери кадра при одиночных бита-ошибках в заголовке. (Это типичная практика в канальном кодировании CCSDS.) 
CCSDS

5) Полудуплексный протокол и защитные интервалы

На GEO CSMA-подобные «прослушал-передай» работают плохо из-за задержки. Сделай строгие guard-intervals и «окна обратной связи».

В tx_pipeline.*: после серии до N фрагментов — окно ожидания ACK размером ACK_TIMEOUT.

В rx_pipeline.*: ACK отправлять склеено (batch ACK) каждые T_ack_agg = 50–100 мс или по заполнению bitmap.

6) Управление ретрансляциями «из архива»

У тебя уже есть архив невыплаченных сообщений — отлично. Дополни:

При любом успешном ACK возвращай ровно столько кадров из архива, сколько свободных слотов в окне SR-ARQ.

Введи приоритет восстановленным фрагментам (впереди новых). Это сократит хвост. (Смотри message_buffer.* и текущую логику архива.) 
 
7) Точное журналирование причин потерь

Добавь к frame_log.* поля: drop_reason (crc_fail/fec_fail/timeout/dup/header_crc_fail), snr_db, ebn0_db, rssi, fec_mode, frag_size.
В веб-интерфейсе (web_interface.*): вкладка Link Diagnostics с графиками PER/RTT/EbN0 и переключателями FEC/интерливера/размера кадра. 
 
8) Синхронный пинг и замеры

Твой satping.* оставить, но:

измеряй RTT пер-фрагмент и RTT пер-сообщение,

выводи 50-й/95-й перцентиль,

логируй вместе с активным fec_mode и frag_size.

9) Криптография и ключи

AES-CCM (tag 8 B) — норм, оверхед умеренный. Для GEO важно безопасное восстановление после потерь при обновлении ключей:

протокол KID-ротации с явным подтверждением «ключ применён» отдельным зашифрованным служебным кадром (с ретраями до успеха).

Скрипт run_key_exchange_test.sh — расширить до e2e сценария: генерация → рассылка → подтверждение → активация.