# Структура работы ESP32 LoRa Pipeline

Этот документ описывает ключевые компоненты проекта и их взаимодействие.

## Основной цикл
- **ESP32_LoRa_Pipeline.ino** — точка входа. Инициализирует радиомодуль, веб‑интерфейс и конвейеры TX/RX. В `loop()` обрабатывает UART‑команды, клиентов HTTP и вызывает `g_tx.loop()` для отправки, а также `g_rx.onReceive()` для обработки принятых кадров.

## Конвейер передачи
1. **MessageBuffer** (`message_buffer.{h,cpp}`)
   - Очередь исходящих сообщений с `msg_id` и приоритетами QoS.
2. **Fragmenter** (`fragmenter.{h,cpp}`)
   - Делит сообщение на фрагменты по MTU и формирует заголовки `FrameHeader`.
3. **Encryptor** (`encryptor.h`, `encryptor_ccm.h`)
   - Плагин шифрования. В базовой реализации `NoEncryptor` передаёт данные как есть.
4. **TxPipeline** (`tx_pipeline.{h,cpp}`)
   - Берёт сообщения из буфера, при необходимости шифрует, отправляет через радио и обрабатывает повторные передачи/ACK.

## Конвейер приёма
1. **RxPipeline** (`rx_pipeline.{h,cpp}`)
   - Получает сырые кадры от радио, выполняет дешифрование, собирает фрагменты и отслеживает дубликаты. При успешной сборке вызывает колбэк приложения с готовыми данными и отправляет ACK при необходимости.
2. **FrameLog / Metrics** (`frame_log.{h,cpp}`, `metrics.h`)
   - Ведут журналы кадров и счётчики успешных/ошибочных операций.

## Вспомогательные файлы
- **frame.h** — формат кадра и расчёт CRC16.
- **config.h** — константы: MTU, таймауты, размеры буферов и флаги компиляции.
- **freq_map.h** — пресеты частот для разных банков и режимов.
- **radio_adapter.h** — абстракция радио‑функций, реализованных в `.ino`.
- **satping.{h,cpp}** — реализация команды Ping с измерением времени и RSSI.

## Поток данных
```
[Приложение] -> MessageBuffer -> Fragmenter -> Encryptor -> Radio ->
  эфир -> Radio -> RxPipeline -> [Колбэк приложения]
```

Функции управления (UART/HTTP) в `.ino` позволяют динамически изменять параметры радиоканала, очередь сообщений и режимы ACK/шифрования.
