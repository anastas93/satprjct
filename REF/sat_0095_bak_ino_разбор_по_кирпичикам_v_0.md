# sat0095bak.ino — полное препарирование (v0.0095)

Авторский разбор: структура, протокол, команды, слабые места и улучшения. Код загружен из присланного файла.

---

## 0) Назначение и общая архитектура
**Задача скетча** — текстовый обмен по LoRa (SX1262) между устройствами ESP32 с адресацией, эхо‑подтверждением, маяком, сканированием каналов и автонастройкой. Управление — через UART и Bluetooth SPP (классический BT), парсер команд — `AsyncStream`.

**Архитектурно**:
- **MCU**: ESP32; **идентификатор** устройства вычисляется из eFuse MAC, адрес (1 байт) — XOR двух байт MAC.
- **RTC**: DS3231 (библиотека `microDS3231`); время используется для логов/печатей.
- **Radio**: `SX1262` (RadioLib) на пине TCXO sense; начальная и динамическая настройка частоты, BW/SF/CR/мощности.
- **Коммуникации**: UART + Bluetooth SPP (`BluetoothSerial`). Вход — строки, завершающиеся `\n`.
- **Режим приема**: прерывание по DIO1 → `setFlag()` → `receivedFlag` → обработчик `received_msg()`.
- **Рабочий цикл**: таймерные задачи (маяк/онлайн), обработка команд, обработка флага приема.

Диаграмма на уровне модулей (логически):
```
[UART/BT] --AsyncStream--> [Парсер команд] --> [Диспетчер]
                                     |                
                                     v                
                                  [RadioLib <-> SX1262] <--> [DIO1 ISR]
                                     ^                
                                     |                
                                [RTC DS3231]
```

---

## 1) Зависимости и железо
- `RadioLib.h` — LoRa SX1262; создание: `SX1262 radio = new Module(5, 26, 27, 25);`
  - В RadioLib порядок аргументов `Module(CS, DIO1, BUSY, NRST)`. Значит: **CS=5, DIO1=26, BUSY=27, RST=25**.
- `microDS3231.h` + `Wire.h` — RTC DS3231.
- `BluetoothSerial.h` — BT SPP (имя `SC<адрес>`, PIN `1234`).
- `AsyncStream.h` — неблокирующий прием строк по UART/BT, буфер **256** байт, терминатор `\n`.
- `UnixTime.h` — вспомогательные конвертеры Unix‑времени (в основном закомментировано).

**TCXO**: пин `TCXO_Pin=15` подтянут внутрь вверх, если LOW — TCXO включен, в `radio.begin(...)` передается «напряжение TCXO».

---

## 2) Радиопараметры и пресеты
- Пары частот **прием/передача** по 10 каналов (активный «банк»):
  - `fRX[10]` и `fTX[10]` — текущий банк (по умолчанию «west», см. §10);
  - командам `~sX` переключается индекс канала `radio_preset` (0–9).
- Полные таблицы для «масc‑скана»: `allRX[167]`/`allTX[167]`.
- Прочие параметры:
  - `BW[5] = {7.81, 10.42, 15.63, 20.83, 31.25}` кГц → `~b0..4`;
  - `SF[8] = {5..12}` → `~f0..7`;
  - `CR[4] = {5..8}` → `~r0..3`;
  - `Pwr[10] = {-5,-2,1,4,7,10,13,16,19,22}` дБм → `~p0..9`.
- Доп.контроль чувствительности приёма: `~g0/1` → `radio.setRxBoostedGainMode()`.

**Инициализация**: `radio.begin(fRX[radio_preset], BW[bw_preset], SF[sf_preset], CR[cr_preset], 0x18, Pwr[pw_preset], 10, tcxo, false)`
> `0x18` — sync word LoRa; `10` — preamble; `tcxo` — напряжение TCXO (см. §11.1 – баг), последний флаг — режим регулятора.

---

## 3) Адресация устройства
- Вычисление 32‑битного `id` на основе старших байт eFuse MAC ESP32, далее массив `address_array[4]` и **адрес устройства** `address = address_array[3] ^ address_array[2]` (1 байт).
- Адрес broadcast фиксирован: `255`.

**Комментарий**: XOR двух байт даёт **256 возможных адресов** и риск коллизий в сети. См. улучшения (§11.4).

---

## 4) Формат пакета (по факту кода)
Все пользовательские пакеты начинаются с 9‑байтового заголовка:

| Байт | Назначение                         |
|------|------------------------------------|
| 0    | **ID‑чек** = `byte1 XOR byte2`     |
| 1    | Случайный ID #1                     |
| 2    | Случайный ID #2                     |
| 3    | Адрес источника                     |
| 4    | Адрес получателя (или 255 = BC)     |
| 5    | Тип/флаги доставки: `0`=обычн., `1`=**требуется эхо**, `2`=**эхо‑подтв.** |
| 6–7  | Резерв (0)                          |
| 8    | Локальный счетчик сообщений (0–255) |
| 9..  | Полезная нагрузка (текст/BEACON/сервис) |

**Пинг/поиск** используют упрощённые короткие кадры на **5 байт** (0–4) без payload.

**Целостность**: доп.проверка — совпадение байта 0 с XOR(1,2). Полноценного CRC/MAC на уровне протокола нет (кроме LoRa CRC).

---

## 5) Жизненный цикл приема
1. В `setup()` → `radio.setDio1Action(setFlag)` и `radio.startReceive()`.
2. ISR `setFlag()` помечает `receivedFlag = true`.
3. В `loop()` при поднятом флаге вызывает `received_msg()`:
   - читает пакет `radio.readData(rx_array, 0)` (предварительно массив обнулён);
   - валидирует ID (0 == 1 XOR 2) и адрес (4 == мой адрес **или** 255);
   - печатает лог (время, RSSI/SNR, ID, адреса, счетчик, текст);
   - если `eho_on==1` и поле 5 == 1 (запрошено подтверждение) — отправляет **эхо** `eho()`;
   - возвращает модуль в прием `RX_start()`.

---

## 6) Передача
### 6.1 Текст широковещательно — `SendMsg_BR()` (`@текст`)
- Формирует заголовок (адрес получателя = 255, поле 5 = 0, счетчик++).
- Текст принимается из `serial.buf`, конвертируется **UTF‑8 → Windows‑1251** (`utf8_win()`), копируется в байтовый буфер и отправляется.

### 6.2 Текст по адресу — `SendMsg_AD()` (`#023текст`)
- Адрес берется из `serial.buf[1..3]` (три десятичные цифры → байт).
- Поле 5: `1` если `eho_on==1`, иначе `0`.
- Текст — **после** префикса `#NNN` (см. замечание об ошибке длины в §11.2).

### 6.3 Эхо‑подтверждение — `eho(addr)`
- Поле 5 = **2**.
- Payload = строка `"eho:<RSSI>/<SNR>"`.

### 6.4 Пинг/дальность — `SatPing()` (`~t`)
- Шлет 5‑байтный пинг (адрес получателя = 0).
- Ждет ответ, считает RTT и оценочную дистанцию:
  `distance_km = ((Δt_µs * 1e-6) * c / 2) / 1000`, выводит RSSI/SNR.

### 6.5 Маяк — `Beacon()` при `beacon_on=1` (`~m1`)
- Каждые 60 с (`beacon_time`) отправляет 15‑байтный пакет с payload `"BEACON"` (ASCII).

---

## 7) Поиск/сканирование/автонастройка
- **Автотюн** `Auto_tune()` (`~a`) — по всем 10 каналам текущего банка: TX пинг → RX → по **SNR** выбирается лучший пресет, переключение на него.
- **Проверка стабильности канала** `Online()` (`~o1`) раз в `online_time` (5 мин): быстрый пинг `ch_ping()`, при неудаче — `Auto_tune()`.
- **Поиск адресата** `Find()` (`~uNNN`) — отсылает сервисный кадр с payload `hunt` и слушает ответ в течение ~2 с; на первом успешном канале — «Found OK».
- **Масс‑скан** `MassPing()` (`~0`) — проходит 167 пресетов (`allRX/TX`) с короткими пингами, считает число «OK».

---

## 8) Командный интерфейс (UART/BT)
Строка → `AsyncStream<256>` (терминатор `\n`). Команды:

### 8.1 Управляющие `~...`
| Команда | Описание |
|---|---|
| `~h` | Справка (Help)
| `~i` | Информация о текущих параметрах
| `~x` | Перезапуск (Radio reset + `ESP.restart()`)
| `~s[0..9]` | Канал (индекс в текущем банке)
| `~p[0..9]` | Мощность в дБм по таблице Pwr (см. §11.1 — баг индекса)
| `~b[0..4]` | Полоса (7.81/10.42/15.63/20.83/31.25 кГц)
| `~f[0..7]` | Spreading Factor (5..12)
| `~r[0..3]` | Coding Rate (5..8)
| `~g0/1` | Boosted RX Gain Off/On
| `~m0/1` | Маяк Off/On
| `~e0/1` | Эхо‑подтверждение Off/On
| `~o0/1` | Онлайн‑мониторинг канала Off/On
| `~t` | Пинг/оценка дистанции
| `~a` | Автонастройка
| `~uNNN` | Поиск адресата (трехзначный адрес в десятичной форме)
| `~c[e|w|t]` | Смена банка частот: **east / west / test**
| `~0` | Масс‑скан всех 167 пресетов

### 8.2 Сообщения
| Команда | Формат |
|---|---|
| Широковещательная | `@текст` (до ~100 символов payload)
| Адресная | `#NNNтекст` (NNN — десятичный адрес 000..255)

> Текст поступает в UTF‑8, перед отправкой конвертируется в **Windows‑1251**. На приеме обратно — в UTF‑8 (`win_utf8()`).

---

## 9) Ключевые функции — краткий разбор
- `setup()` — инициализация UART, RadioLib (`begin`), установка DIO1 ISR, старт приема, печать времени/даты, `Help()`, запуск Bluetooth.
- `loop()` — таймерные задачи (маяк/онлайн), прием команд из UART/BT, диспетчер команд, обработка флага приема.
- `received_msg()` — чтение кадра, проверка ID/адреса, печать, обработка `Msg delivered`, эхо при запросе, возврат в Rx.
- `SendMsg_BR()/SendMsg_AD()` — сборка заголовка + кодировка текста + передача.
- `eho()` — подтверждение доставки с RSSI/SNR в payload.
- `SatPing()` — 5‑байтный пинг + расчет RTS/дистанции.
- `Auto_tune()/ch_ping()/Online()` — проверка канала, автонастройка по SNR.
- `Find_TX_RX()/Find()` — направленный поиск адресата по 10 каналам.
- `MassPing()` — проход по `allRX/allTX`.
- `SetPreset/SetPower/SetBW/SpreadingFactor/CodingRate/Beacon_on/Eho_on/Online_on/BoostedGain_on/Frequency_change` — обработчики команд.

---

## 10) Банки частот
Поддерживаются три 10‑канальных банка для `fRX[]/fTX[]`:
- **east** (`~ce`) — `fRX_east[] / fTX_east[]`
- **west** (`~cw`) — `fRX_west[] / fTX_west[]` (по умолчанию)
- **test** (`~ct`) — `fRX_test[] / fTX_test[]`

Смена банка — через `memcpy` массивов и печать списка десяти частот (с тремя знаками после запятой).

---

## 11) Баги/острые углы (прямо)
### 11.1 **TCXO тип**
```cpp
int tcxo = 0;                   // сейчас так
if (LOW) { tcxo = 2.4; }        // присваивается дробное, но переменная целая!
// radio.begin(..., tcxo, ...)
```
**Ошибка типов**: `2.4` усечется до `2`. Нужно `float tcxo = 0.0f;` и присваивать `2.4f`.

### 11.2 **Длина полезной нагрузки при отправке**
- В `SendMsg_BR()` размер передачи берется как `9 + win_buf.length()`,
  но в буфер копируется **макс. 100** байт. Если строка >100, уйдет «лишняя длина» → выход за пределы буфера/мусор.
- В `SendMsg_AD()` аналогично и дополнительно payload фактически начинается **после префикса `#NNN`**, но длина не корректируется на `-4`.

**Исправить** (идея):
```cpp
const size_t MAX_PAY = 100;
size_t textLen = min(win_buf.length(), MAX_PAY);
// для адресной — textLen = max<int>(0, min<int>(MAX_PAY, win_buf.length() - 4));
radio.transmit(new_packet, 9 + textLen);
```

### 11.3 **SetPower() — неверный индекс**
```cpp
pw_preset = X;
radio.setOutputPower(Pwr[bw_preset]); // ТАК СЕЙЧАС — ошибка
// нужно
radio.setOutputPower(Pwr[pw_preset]);
```
Иначе мощность выбирается «как будто» по индексу полосы, а не мощности.

### 11.4 **Адресация 1 байт (XOR)**
XOR двух байт MAC даёт 256 значений → возможны **коллизии** на сети из нескольких узлов. Лучше:
- либо хранить **2‑байтный адрес**,
- либо детерминированно хешировать MAC и проверять коллизии в сети.

### 11.5 **`boosted_on`/`state` в `BoostedGain_on()`**
`int state;` может остаться неинициализирован, если пришел неизвестный символ → затем печатается.
Решение: инициировать `state = RADIOLIB_ERR_NONE;` и печатать только при изменении, либо иметь `default: return;`.

### 11.6 **Границы команд/входа**
Местами есть доступы к `serial.buf[n]` без проверки длины строки (например, `~s?`, `~p?`, `~uNNN`, `~c?`).
Добавить валидацию: длина ≥ нужного количества символов, цифры/буквы по месту.

### 11.7 **Критичность флага из ISR**
`receivedFlag` должен быть `volatile`, т.к. меняется в ISR и читается в главном цикле:
```cpp
volatile bool receivedFlag = false;
```

### 11.8 **Задержки/блокировки**
`receive()`/`delay()` блокируют цикл (автотюн, масс‑скан, пинг). При необходимости совместимости с другим функционалом — стоит вынести в планировщик/Coop multitasking.

### 11.9 **Копирование BT → UART буфера**
`memcpy(serial.buf, serialBT.buf, 256);` копирует **весь** буфер `256` байт, включая «хвост». Лучше копировать фактическую длину полученной строки или работать своим парсером поверх `serialBT`.

### 11.10 **Безопасность/целостность**
Проверка `ID = XOR(1,2)` слабая. Для помехоустойчивой доставки — добавьте хотя бы 1‑байтный **CRC payload**, для защищенности — простой HMAC.

---

## 12) Рекомендации по рефакторингу
1. **Типы и константы**: завести `enum` для поля 5 (тип пакета), `constexpr` для размеров буферов, таймаутов, частот.
2. **Структуры пакетов**: описать `struct PacketHeader { ... }` и функции `encode/decode`, чтобы исключить «магические индексы».
3. **Гигиена буферов**: явная нормализация длины, `std::min(...)`, `memset` под фактическую длину, `String` → `std::string`/`span` при переходе на IDF.
4. **Адресация**: перейти на 16‑битный адрес; сохранить совместимость через режим «legacy 8‑бит» при желании.
5. **Не блокировать `loop()`**: обернуть пинги/тест в «состояния» + таймеры; или использовать FreeRTOS задачи.
6. **Команды**: свести в таблицу `{префикс, проверка, хендлер}`, выбрасывать ошибки синтаксиса.
7. **Логирование**: унифицировать `Print/Println` (уровни, префиксы, вывод в BT/UART).
8. **Юникод**: по возможности хранить и передавать текст в **UTF‑8** без вин1251; конвертировать только для совместимости.

---

## 13) Патч‑фрагменты (готовые правки)
**13.1 Заголовок/глобальные**
```cpp
// было
bool receivedFlag = false;
int tcxo = 0;
// стало
volatile bool receivedFlag = false;
float tcxo = 0.0f;
```

**13.2 SetPower()**
```cpp
void SetPower() {
  switch (serial.buf[2]) {
    case '0': pw_preset = 0; break;
    case '1': pw_preset = 1; break;
    case '2': pw_preset = 2; break;
    case '3': pw_preset = 3; break;
    case '4': pw_preset = 4; break;
    case '5': pw_preset = 5; break;
    case '6': pw_preset = 6; break;
    case '7': pw_preset = 7; break;
    case '8': pw_preset = 8; break;
    case '9': pw_preset = 9; break;
    default: return; // неправильный символ
  }
  radio.setOutputPower(Pwr[pw_preset]);
  Println("Power set " + String(Pwr[pw_preset]));
}
```

**13.3 BoostedGain_on()**
```cpp
void BoostedGain_on() {
  int state = RADIOLIB_ERR_NONE;
  if (serial.buf[2] == '0') {
    boosted_on = 0;
    state = radio.setRxBoostedGainMode(false, true);
    Println("Boosted Gain - off");
  } else if (serial.buf[2] == '1') {
    boosted_on = 1;
    state = radio.setRxBoostedGainMode(true, true);
    Println("Boosted Gain - on");
  } else {
    return; // некорректный ввод
  }
  if (state != RADIOLIB_ERR_NONE) {
    Println("failed, code " + String(state));
  }
}
```

**13.4 Ограничения длины текста**
```cpp
const size_t MAX_PAY = 100;

void SendMsg_BR() {
  ...
  String win_buf = utf8_win(serial.buf);
  size_t textLen = min(win_buf.length(), MAX_PAY);
  byte win_array[MAX_PAY+1] = {0};
  win_buf.getBytes(win_array, textLen + 1);
  for (size_t i = 0; i < textLen; i++) new_packet[9 + i] = win_array[i];
  radio.setFrequency(fTX[radio_preset]);
  radio.transmit(new_packet, 9 + textLen);
  ...
}

void SendMsg_AD() {
  ...
  String win_buf = utf8_win(serial.buf);
  size_t textLen = (win_buf.length() > 4) ? min<size_t>(MAX_PAY, win_buf.length() - 4) : 0;
  byte win_array[MAX_PAY+5] = {0};
  win_buf.getBytes(win_array, textLen + 5); // с учетом префикса
  for (size_t i = 0; i < textLen; i++) new_packet[9 + i] = win_array[4 + i];
  radio.setFrequency(fTX[radio_preset]);
  radio.transmit(new_packet, 9 + textLen);
  ...
}
```

**13.5 Ввод — валидация длины** (пример)
```cpp
bool hasArg(size_t n) { return strlen((const char*)serial.buf) > n; }
// перед чтением serial.buf[2] и т.п.: if (!hasArg(2)) { Println("Bad args"); return; }
```

---

## 14) Список функций (по исходнику)
`setup, loop, setFlag, SatPing, SetBW, SetPreset, SetPower, Help, Beacon, Beacon_on, SpreadingFactor, CodingRate, Println, Print, Print_hex, RX_start, received_msg, Auto_tune, SendMsg_BR, SendMsg_AD, utf8_win, win_utf8, eho, Eho_on, info, BoostedGain_on, Find_TX_RX, Find, Online_on, ch_ping, Online, MassPing, all_ping, Frequency_change`.

---

## 15) Итоги
- Протокол и логика корректны и понятны;
- Есть **несколько критичных мелочей**, влияющих на точность (тип `tcxo`), мощность (индексация), стабильность (длины payload), читаемость (`volatile`, enum/struct).
- Внедрение фиксов из §13 + валидации входа сделает систему заметно надежнее без фрагментации архитектуры.

Если нужно — подготовлю **патч‑ветку** с правками и регрессионными тестами на парсинг/сборку пакетов.


---

## 16) Глубокий разбор: ПРИЁМ ↔ ПЕРЕДАЧА и переключения между функциями
Ниже — подробно, по шагам, как устроены оба контура (RX и TX), где именно происходит переключение состояний и кто кого вызывает. Разбираю **фактический код** из `sat0095bak.ino`.

### 16.1 Базовая инициализация приёма (RX)
1) В `setup()` после `radio.begin(...)` настраивается ISR и немедленно включается неблокирующий приём:
```
radio.setDio1Action(setFlag);   // назначаем обработчик
state = radio.startReceive();   // «встать на уши»: непрерывный RX
```
2) ISR:
```
void setFlag() { receivedFlag = true; }
```
`receivedFlag` — **volatile** (в исходнике так и объявлен), т.е. корректно виден вне ISR.

3) Универсальная функция возврата в RX:
```
void RX_start() {
  receivedFlag = false;
  radio.setFrequency(fRX[radio_preset]);
  radio.startReceive();
}
```
Её вызывают из `loop()` после обработки команд, а также в конце `received_msg()` и некоторых сервисных функций.

> Итог: «нормальный» режим работы — **неблокирующий приём** с прерыванием по `DIO1`; как только придёт пакет — ISR поднимет флаг, основной цикл разрулит.

### 16.2 Контур приёма (interrupt-driven)
**Главный цикл:**
```
void loop() {
  if (online_on) Online();      // периодика
  if (beacon_on) Beacon();
  ...                           // приём команд с UART/BT
  if (serial.available() || serialBT.available()) {
    ... // разбор и вызов обработчиков
    RX_start();                 // всегда уходим в прослушку
  }
  if (receivedFlag) received_msg();   // асинхронный приём
}
```
**Обработка принятого пакета:**
```
void received_msg() {
  receivedFlag = false;                 // сброс флага
  byte rx_array[109] = {0};
  int state = radio.readData(rx_array, 0); // чтение кадра из FIFO
  // Валидация: ID (XOR), адрес (мой или 255)
  // Логирование, печать RSSI/SNR
  // Эхо (если запрос и eho_on==1): eho(addr_source)
  RX_start();                           // обратно в RX
}
```
Ключевые моменты:
- `radio.startReceive()` был активен заранее; ISR лишь сообщает «готово». Сам кадр читается **вне ISR** через `radio.readData()`.
- После обработки **всегда** вызывается `RX_start()` → приём немедленно возобновляется на `fRX[radio_preset]`.

### 16.3 Контур передачи (TX) — общие шаги
Любая передача (шлём текст, эхо, маяк, пинг) следует схеме:
1) Сборка пакета (заголовок + payload).
2) `radio.setFrequency(fTX[radio_preset]);`
3) `radio.transmit(buf, len);`  // **блокирующий** вызов RadioLib
4) `radio.setFrequency(fRX[radio_preset]);`
5) (иногда) `delay(delay_time);` и сброс `receivedFlag`.
6) Возврат в RX достигается либо **вызовом `RX_start()`** снаружи (после обработчика команды), либо самим обработчиком (например, в `received_msg()`), либо внутри функции (редко — как в `Beacon()`).

### 16.4 Передача: широковещательная и адресная
**Широковещание `@текст` → `SendMsg_BR()`**
```
new_packet[1..2] = random ID; new_packet[0] = XOR(1,2);
new_packet[3] = address;      // мой адрес
new_packet[4] = 255;          // broadcast
new_packet[5] = 0;            // тип: обычный
new_packet[8] = счетчик 0..255;
// payload: текст (UTF-8 → Win1251) в new_packet[9..]
radio.setFrequency(fTX[idx]);
radio.transmit(new_packet, 9 + win_buf.length());
radio.setFrequency(fRX[idx]);
receivedFlag = false;  // очистка «на всякий»
// В реальный RX переводит внешний RX_start() из loop()
```
**Адресная `#NNNтекст` → `SendMsg_AD()`** — аналогично, но `new_packet[4] = адрес_получателя`, `new_packet[5] = 1`, если `eho_on==1` (требуется эхо).

> В обоих случаях **startReceive() не вызывается внутри функции** — на приём возвращаемся за счёт `RX_start()` в конце командного блока `loop()`.

### 16.5 Авто-эхо → `eho(addr)` (ответ на доставку)
В `received_msg()` при пришедшем кадре с `тип=1` и включённом `eho_on` вызывается `eho(addr_source)`:
```
// Формируется короткий кадр с текстом "eho:<RSSI>/<SNR>"
eho[3] = мой_адрес; eho[4] = addr_source; eho[5] = 2; // тип=2 (эхо)
radio.setFrequency(fTX[idx]);
radio.transmit(eho, 9 + payload_len);
radio.setFrequency(fRX[idx]);
// Возврат в реальный RX делает вызывавший received_msg() → RX_start()
```

### 16.6 Пинг и синхронные ожидания (modal)
Есть класс функций, которые **временно выключают неблокирующий RX** и сами синхронно ждут ответ — без `receivedFlag` и без ISR:
- `SatPing()` — 5‑байтный пинг + `radio.receive(rx_ping, 5)` (блокирующий приём), расчёт RTT/дистанции.
- `ch_ping()` — краткая проверка канала (используется в `Online()`), тоже через `radio.receive(...)`.
- `Find_TX_RX()` — сервисный «hunt» кадр и синхронное `receive(...)` c обработкой кодов статуса.
- `Auto_tune()` — цикл по 10 пресетам с пингом/приёмом, выбор по максимальному SNR.

Общий паттерн (на примере `SatPing()`):
```
radio.setFrequency(fTX[idx]);
radio.transmit(ping, 5);
radio.setFrequency(fRX[idx]);
int state = radio.receive(rx_ping, 5);  // БЛОКИРУЮЩЕ ждём ответ
... // анализ результата
receivedFlag = false;
```
Возврат в «неблокирующий мир» обеспечивается **внешним** `RX_start()`:
- для `Online()` — он сам в конце вызывает `RX_start();`
- при запуске `Auto_tune()` как отдельной команды — `loop()` после выхода из обработчика команд сделает `RX_start();`

### 16.7 Маяк (периодика)
`Beacon()` раз в `beacon_time` (60s) шлёт 15‑байтный кадр `"BEACON"` и **сам** возвращает модуль в неблокирующий приём:
```
radio.transmit(beacon_array, 15);
radio.setFrequency(fRX[idx]);
receivedFlag = false;
radio.startReceive();   // исключение: сразу включаем RX
```

### 16.8 Где именно происходит «переключение»
- **RX → TX**: внутри конкретной функции передачи через `radio.setFrequency(fTX[...]); radio.transmit(...);`
- **TX → RX (частота)**: немедленно после `transmit()` — `radio.setFrequency(fRX[...]);`
- **TX/RX → неблокирующий RX**: либо `RX_start()` (универсально), либо локально `radio.startReceive()` (например, в `Beacon()`).
- **Асинхронный приём**: `radio.startReceive()` + ISR `setFlag()` + `received_msg()`.
- **Синхронный приём**: `radio.receive(buf, n)` **без** ISR/флага (пинги, поиск, авто‑тюн).

### 16.9 Последовательности (лестницы вызовов)
**A) Пришло адресное сообщение, требуется эхо**
```
[startReceive] → (эфир) → [DIO1 ISR:setFlag]
loop → received_msg
  ├─ readData + валидация
  ├─ печать логов
  ├─ if (тип==1 && eho_on) → eho(addr_src)
  │     ├─ setFrequency(TX) → transmit(eho)
  │     └─ setFrequency(RX)
  └─ RX_start() → startReceive
```
**B) Мы отправляем адресное `#NNN`**
```
loop читает команду → SendMsg_AD
  ├─ сборка заголовка/текста
  ├─ setFrequency(TX) → transmit
  └─ setFrequency(RX) + receivedFlag=false
(выход в loop) → RX_start() → startReceive
```
**C) Пинг канала (~t / Online/ch_ping)**
```
setFrequency(TX) → transmit(ping)
setFrequency(RX) → receive(rx_ping,5) [блокирующе]
анализ → (внешний) RX_start()
```

### 16.10 Важные нюансы/острые места по переключениям
1) **`delay(delay_time)` после передач** (`SendMsg_*`, `eho`, `SatPing`) — искусственное окно ~500 мс. RadioLib `transmit()` уже блокирует до завершения TX; задержку можно убрать или сделать опциональной (см. §16.11-1).
2) В `SendMsg_*` **нет локального `startReceive()`** — возврат в RX зависит от вызова `RX_start()` в `loop()` после команд. Это нормально, но уделить внимание потокам, вызывающим передачу **вне** команд (например, из колбэков) — там нужно самим дергать `RX_start()`.
3) **Смешение async/sync**: асинхронный приём (`startReceive`+ISR) и синхронные `receive(...)` сосуществуют. Пока это безопасно, т.к. синхронные участки явно управляют частотой и не оставляют `startReceive` активным.
4) **Сброс `receivedFlag`** делается и в `RX_start()`, и локально после TX. Это не ломает логику, но дублирование.
5) **Частоты RX/TX**: строго переключаются одним и тем же индексом `radio_preset`. Любая смена канала/банка должна завершаться `RX_start()`.

### 16.11 Рекомендации усилить надёжность переключений
1) **Убрать фиксированную задержку** после TX. Вместо `delay(delay_time)` — ждать флаг «TX done» из RadioLib (если доступен) или проверять `state` из `transmit()`. Это закроет «глухое окно».
2) **Единая обёртка «TX с авто‑возвратом»**:
```
int tx_then_rx(const uint8_t* p, size_t n) {
  radio.setFrequency(fTX[radio_preset]);
  int st = radio.transmit(p, n);
  radio.setFrequency(fRX[radio_preset]);
  RX_start();     // гарантируем возврат в async RX здесь же
  return st;
}
```
3) **Один стиль приёма**: либо везде async (`startReceive`+ISR), либо явный «modal» — сейчас допустим гибрид, но лучше минимизировать `receive(...)` вне сервисных диагностик.
4) **Защита от гонок**: на время TX можно явно гасить прерывание DIO1 (если RadioLib не делает это сам) → исключить ложные `setFlag`.
5) **Валидация длины payload до TX** (см. §13) — исключить мусор в буфере, из‑за него приём/эхо может расходиться.

### 16.12 Небольшая коррекция моего прошлого комментария
Ранее я отметил, что `receivedFlag` нужно сделать `volatile`. **В исходнике он уже `volatile`** — тут всё правильно. Поправка внесена в этот разбор.

---

## 17) Мини‑шпаргалка по ключевым переходам
- **Старт RX:** `startReceive()` в `setup()` и `RX_start()`
- **Сигнал приёма:** `DIO1 → setFlag()`
- **Разбор принятого:** `received_msg()`
- **Передача данных:** `SendMsg_BR/AD()` → `transmit()`
- **Эхо:** `received_msg()` → `eho()` → назад в `RX_start()`
- **Пинг/проверка:** `SatPing()/ch_ping()/Find_TX_RX()` используют `receive()` (блокирующе)
- **Возврат в приём:** либо внутри `Beacon()`, либо универсально через `RX_start()`
