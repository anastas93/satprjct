# sat0095bak.ino — полное препарирование (v0.0095)

Авторский разбор: структура, протокол, команды, слабые места и улучшения. Код загружен из присланного файла.

---

## 0) Назначение и общая архитектура
**Задача скетча** — текстовый обмен по LoRa (SX1262) между устройствами ESP32 с адресацией, эхо‑подтверждением, маяком, сканированием каналов и автонастройкой. Управление — через UART и Bluetooth SPP (классический BT), парсер команд — `AsyncStream`.

**Архитектурно**:
- **MCU**: ESP32; **идентификатор** устройства вычисляется из eFuse MAC, адрес (1 байт) — XOR двух байт MAC.
- **RTC**: DS3231 (библиотека `microDS3231`); время используется для логов/печатей.
- **Radio**: `SX1262` (RadioLib) на пине TCXO sense; начальная и динамическая настройка частоты, BW/SF/CR/мощности.
- **Коммуникации**: UART + Bluetooth SPP (`BluetoothSerial`). Вход — строки, завершающиеся `\n`.
- **Режим приема**: прерывание по DIO1 → `setFlag()` → `receivedFlag` → обработчик `received_msg()`.
- **Рабочий цикл**: таймерные задачи (маяк/онлайн), обработка команд, обработка флага приема.

Диаграмма на уровне модулей (логически):
```
[UART/BT] --AsyncStream--> [Парсер команд] --> [Диспетчер]
                                     |                
                                     v                
                                  [RadioLib <-> SX1262] <--> [DIO1 ISR]
                                     ^                
                                     |                
                                [RTC DS3231]
```

---

## 1) Зависимости и железо
- `RadioLib.h` — LoRa SX1262; создание: `SX1262 radio = new Module(5, 26, 27, 25);`
  - В RadioLib порядок аргументов `Module(CS, DIO1, BUSY, NRST)`. Значит: **CS=5, DIO1=26, BUSY=27, RST=25**.
- `microDS3231.h` + `Wire.h` — RTC DS3231.
- `BluetoothSerial.h` — BT SPP (имя `SC<адрес>`, PIN `1234`).
- `AsyncStream.h` — неблокирующий прием строк по UART/BT, буфер **256** байт, терминатор `\n`.
- `UnixTime.h` — вспомогательные конвертеры Unix‑времени (в основном закомментировано).

**TCXO**: пин `TCXO_Pin=15` подтянут внутрь вверх, если LOW — TCXO включен, в `radio.begin(...)` передается «напряжение TCXO».

---

## 2) Радиопараметры и пресеты
- Пары частот **прием/передача** по 10 каналов (активный «банк»):
  - `fRX[10]` и `fTX[10]` — текущий банк (по умолчанию «west», см. §10);
  - командам `~sX` переключается индекс канала `radio_preset` (0–9).
- Полные таблицы для «масc‑скана»: `allRX[167]`/`allTX[167]`.
- Прочие параметры:
  - `BW[5] = {7.81, 10.42, 15.63, 20.83, 31.25}` кГц → `~b0..4`;
  - `SF[8] = {5..12}` → `~f0..7`;
  - `CR[4] = {5..8}` → `~r0..3`;
  - `Pwr[10] = {-5,-2,1,4,7,10,13,16,19,22}` дБм → `~p0..9`.
- Доп.контроль чувствительности приёма: `~g0/1` → `radio.setRxBoostedGainMode()`.

**Инициализация**: `radio.begin(fRX[radio_preset], BW[bw_preset], SF[sf_preset], CR[cr_preset], 0x18, Pwr[pw_preset], 10, tcxo, false)`
> `0x18` — sync word LoRa; `10` — preamble; `tcxo` — напряжение TCXO (см. §11.1 – баг), последний флаг — режим регулятора.

---

## 3) Адресация устройства
- Вычисление 32‑битного `id` на основе старших байт eFuse MAC ESP32, далее массив `address_array[4]` и **адрес устройства** `address = address_array[3] ^ address_array[2]` (1 байт).
- Адрес broadcast фиксирован: `255`.

**Комментарий**: XOR двух байт даёт **256 возможных адресов** и риск коллизий в сети. См. улучшения (§11.4).

---

## 4) Формат пакета (по факту кода)
Все пользовательские пакеты начинаются с 9‑байтового заголовка:

| Байт | Назначение                         |
|------|------------------------------------|
| 0    | **ID‑чек** = `byte1 XOR byte2`     |
| 1    | Случайный ID #1                     |
| 2    | Случайный ID #2                     |
| 3    | Адрес источника                     |
| 4    | Адрес получателя (или 255 = BC)     |
| 5    | Тип/флаги доставки: `0`=обычн., `1`=**требуется эхо**, `2`=**эхо‑подтв.** |
| 6–7  | Резерв (0)                          |
| 8    | Локальный счетчик сообщений (0–255) |
| 9..  | Полезная нагрузка (текст/BEACON/сервис) |

**Пинг/поиск** используют упрощённые короткие кадры на **5 байт** (0–4) без payload.

**Целостность**: доп.проверка — совпадение байта 0 с XOR(1,2). Полноценного CRC/MAC на уровне протокола нет (кроме LoRa CRC).

---

## 5) Жизненный цикл приема
1. В `setup()` → `radio.setDio1Action(setFlag)` и `radio.startReceive()`.
2. ISR `setFlag()` помечает `receivedFlag = true`.
3. В `loop()` при поднятом флаге вызывает `received_msg()`:
   - читает пакет `radio.readData(rx_array, 0)` (предварительно массив обнулён);
   - валидирует ID (0 == 1 XOR 2) и адрес (4 == мой адрес **или** 255);
   - печатает лог (время, RSSI/SNR, ID, адреса, счетчик, текст);
   - если `eho_on==1` и поле 5 == 1 (запрошено подтверждение) — отправляет **эхо** `eho()`;
   - возвращает модуль в прием `RX_start()`.

---

## 6) Передача
### 6.1 Текст широковещательно — `SendMsg_BR()` (`@текст`)
- Формирует заголовок (адрес получателя = 255, поле 5 = 0, счетчик++).
- Текст принимается из `serial.buf`, конвертируется **UTF‑8 → Windows‑1251** (`utf8_win()`), копируется в байтовый буфер и отправляется.

### 6.2 Текст по адресу — `SendMsg_AD()` (`#023текст`)
- Адрес берется из `serial.buf[1..3]` (три десятичные цифры → байт).
- Поле 5: `1` если `eho_on==1`, иначе `0`.
- Текст — **после** префикса `#NNN` (см. замечание об ошибке длины в §11.2).

### 6.3 Эхо‑подтверждение — `eho(addr)`
- Поле 5 = **2**.
- Payload = строка `"eho:<RSSI>/<SNR>"`.

### 6.4 Пинг/дальность — `SatPing()` (`~t`)
- Шлет 5‑байтный пинг (адрес получателя = 0).
- Ждет ответ, считает RTT и оценочную дистанцию:
  `distance_km = ((Δt_µs * 1e-6) * c / 2) / 1000`, выводит RSSI/SNR.

### 6.5 Маяк — `Beacon()` при `beacon_on=1` (`~m1`)
- Каждые 60 с (`beacon_time`) отправляет 15‑байтный пакет с payload `"BEACON"` (ASCII).

---

## 7) Поиск/сканирование/автонастройка
- **Автотюн** `Auto_tune()` (`~a`) — по всем 10 каналам текущего банка: TX пинг → RX → по **SNR** выбирается лучший пресет, переключение на него.
- **Проверка стабильности канала** `Online()` (`~o1`) раз в `online_time` (5 мин): быстрый пинг `ch_ping()`, при неудаче — `Auto_tune()`.
- **Поиск адресата** `Find()` (`~uNNN`) — отсылает сервисный кадр с payload `hunt` и слушает ответ в течение ~2 с; на первом успешном канале — «Found OK».
- **Масс‑скан** `MassPing()` (`~0`) — проходит 167 пресетов (`allRX/TX`) с короткими пингами, считает число «OK».

---

## 8) Командный интерфейс (UART/BT)
Строка → `AsyncStream<256>` (терминатор `\n`). Команды:

### 8.1 Управляющие `~...`
| Команда | Описание |
|---|---|
| `~h` | Справка (Help)
| `~i` | Информация о текущих параметрах
| `~x` | Перезапуск (Radio reset + `ESP.restart()`)
| `~s[0..9]` | Канал (индекс в текущем банке)
| `~p[0..9]` | Мощность в дБм по таблице Pwr (см. §11.1 — баг индекса)
| `~b[0..4]` | Полоса (7.81/10.42/15.63/20.83/31.25 кГц)
| `~f[0..7]` | Spreading Factor (5..12)
| `~r[0..3]` | Coding Rate (5..8)
| `~g0/1` | Boosted RX Gain Off/On
| `~m0/1` | Маяк Off/On
| `~e0/1` | Эхо‑подтверждение Off/On
| `~o0/1` | Онлайн‑мониторинг канала Off/On
| `~t` | Пинг/оценка дистанции
| `~a` | Автонастройка
| `~uNNN` | Поиск адресата (трехзначный адрес в десятичной форме)
| `~c[e|w|t]` | Смена банка частот: **east / west / test**
| `~0` | Масс‑скан всех 167 пресетов

### 8.2 Сообщения
| Команда | Формат |
|---|---|
| Широковещательная | `@текст` (до ~100 символов payload)
| Адресная | `#NNNтекст` (NNN — десятичный адрес 000..255)

> Текст поступает в UTF‑8, перед отправкой конвертируется в **Windows‑1251**. На приеме обратно — в UTF‑8 (`win_utf8()`).

---

## 9) Ключевые функции — краткий разбор
- `setup()` — инициализация UART, RadioLib (`begin`), установка DIO1 ISR, старт приема, печать времени/даты, `Help()`, запуск Bluetooth.
- `loop()` — таймерные задачи (маяк/онлайн), прием команд из UART/BT, диспетчер команд, обработка флага приема.
- `received_msg()` — чтение кадра, проверка ID/адреса, печать, обработка `Msg delivered`, эхо при запросе, возврат в Rx.
- `SendMsg_BR()/SendMsg_AD()` — сборка заголовка + кодировка текста + передача.
- `eho()` — подтверждение доставки с RSSI/SNR в payload.
- `SatPing()` — 5‑байтный пинг + расчет RTS/дистанции.
- `Auto_tune()/ch_ping()/Online()` — проверка канала, автонастройка по SNR.
- `Find_TX_RX()/Find()` — направленный поиск адресата по 10 каналам.
- `MassPing()` — проход по `allRX/allTX`.
- `SetPreset/SetPower/SetBW/SpreadingFactor/CodingRate/Beacon_on/Eho_on/Online_on/BoostedGain_on/Frequency_change` — обработчики команд.

---

## 10) Банки частот
Поддерживаются три 10‑канальных банка для `fRX[]/fTX[]`:
- **east** (`~ce`) — `fRX_east[] / fTX_east[]`
- **west** (`~cw`) — `fRX_west[] / fTX_west[]` (по умолчанию)
- **test** (`~ct`) — `fRX_test[] / fTX_test[]`

Смена банка — через `memcpy` массивов и печать списка десяти частот (с тремя знаками после запятой).

---

## 11) Баги/острые углы (прямо)
### 11.1 **TCXO тип**
```cpp
int tcxo = 0;                   // сейчас так
if (LOW) { tcxo = 2.4; }        // присваивается дробное, но переменная целая!
// radio.begin(..., tcxo, ...)
```
**Ошибка типов**: `2.4` усечется до `2`. Нужно `float tcxo = 0.0f;` и присваивать `2.4f`.

### 11.2 **Длина полезной нагрузки при отправке**
- В `SendMsg_BR()` размер передачи берется как `9 + win_buf.length()`,
  но в буфер копируется **макс. 100** байт. Если строка >100, уйдет «лишняя длина» → выход за пределы буфера/мусор.
- В `SendMsg_AD()` аналогично и дополнительно payload фактически начинается **после префикса `#NNN`**, но длина не корректируется на `-4`.

**Исправить** (идея):
```cpp
const size_t MAX_PAY = 100;
size_t textLen = min(win_buf.length(), MAX_PAY);
// для адресной — textLen = max<int>(0, min<int>(MAX_PAY, win_buf.length() - 4));
radio.transmit(new_packet, 9 + textLen);
```

### 11.3 **SetPower() — неверный индекс**
```cpp
pw_preset = X;
radio.setOutputPower(Pwr[bw_preset]); // ТАК СЕЙЧАС — ошибка
// нужно
radio.setOutputPower(Pwr[pw_preset]);
```
Иначе мощность выбирается «как будто» по индексу полосы, а не мощности.

### 11.4 **Адресация 1 байт (XOR)**
XOR двух байт MAC даёт 256 значений → возможны **коллизии** на сети из нескольких узлов. Лучше:
- либо хранить **2‑байтный адрес**,
- либо детерминированно хешировать MAC и проверять коллизии в сети.

### 11.5 **`boosted_on`/`state` в `BoostedGain_on()`**
`int state;` может остаться неинициализирован, если пришел неизвестный символ → затем печатается.
Решение: инициировать `state = RADIOLIB_ERR_NONE;` и печатать только при изменении, либо иметь `default: return;`.

### 11.6 **Границы команд/входа**
Местами есть доступы к `serial.buf[n]` без проверки длины строки (например, `~s?`, `~p?`, `~uNNN`, `~c?`).
Добавить валидацию: длина ≥ нужного количества символов, цифры/буквы по месту.

### 11.7 **Критичность флага из ISR**
`receivedFlag` должен быть `volatile`, т.к. меняется в ISR и читается в главном цикле:
```cpp
volatile bool receivedFlag = false;
```

### 11.8 **Задержки/блокировки**
`receive()`/`delay()` блокируют цикл (автотюн, масс‑скан, пинг). При необходимости совместимости с другим функционалом — стоит вынести в планировщик/Coop multitasking.

### 11.9 **Копирование BT → UART буфера**
`memcpy(serial.buf, serialBT.buf, 256);` копирует **весь** буфер `256` байт, включая «хвост». Лучше копировать фактическую длину полученной строки или работать своим парсером поверх `serialBT`.

### 11.10 **Безопасность/целостность**
Проверка `ID = XOR(1,2)` слабая. Для помехоустойчивой доставки — добавьте хотя бы 1‑байтный **CRC payload**, для защищенности — простой HMAC.

---

## 12) Рекомендации по рефакторингу
1. **Типы и константы**: завести `enum` для поля 5 (тип пакета), `constexpr` для размеров буферов, таймаутов, частот.
2. **Структуры пакетов**: описать `struct PacketHeader { ... }` и функции `encode/decode`, чтобы исключить «магические индексы».
3. **Гигиена буферов**: явная нормализация длины, `std::min(...)`, `memset` под фактическую длину, `String` → `std::string`/`span` при переходе на IDF.
4. **Адресация**: перейти на 16‑битный адрес; сохранить совместимость через режим «legacy 8‑бит» при желании.
5. **Не блокировать `loop()`**: обернуть пинги/тест в «состояния» + таймеры; или использовать FreeRTOS задачи.
6. **Команды**: свести в таблицу `{префикс, проверка, хендлер}`, выбрасывать ошибки синтаксиса.
7. **Логирование**: унифицировать `Print/Println` (уровни, префиксы, вывод в BT/UART).
8. **Юникод**: по возможности хранить и передавать текст в **UTF‑8** без вин1251; конвертировать только для совместимости.

---

## 13) Патч‑фрагменты (готовые правки)
**13.1 Заголовок/глобальные**
```cpp
// было
bool receivedFlag = false;
int tcxo = 0;
// стало
volatile bool receivedFlag = false;
float tcxo = 0.0f;
```

**13.2 SetPower()**
```cpp
void SetPower() {
  switch (serial.buf[2]) {
    case '0': pw_preset = 0; break;
    case '1': pw_preset = 1; break;
    case '2': pw_preset = 2; break;
    case '3': pw_preset = 3; break;
    case '4': pw_preset = 4; break;
    case '5': pw_preset = 5; break;
    case '6': pw_preset = 6; break;
    case '7': pw_preset = 7; break;
    case '8': pw_preset = 8; break;
    case '9': pw_preset = 9; break;
    default: return; // неправильный символ
  }
  radio.setOutputPower(Pwr[pw_preset]);
  Println("Power set " + String(Pwr[pw_preset]));
}
```

**13.3 BoostedGain_on()**
```cpp
void BoostedGain_on() {
  int state = RADIOLIB_ERR_NONE;
  if (serial.buf[2] == '0') {
    boosted_on = 0;
    state = radio.setRxBoostedGainMode(false, true);
    Println("Boosted Gain - off");
  } else if (serial.buf[2] == '1') {
    boosted_on = 1;
    state = radio.setRxBoostedGainMode(true, true);
    Println("Boosted Gain - on");
  } else {
    return; // некорректный ввод
  }
  if (state != RADIOLIB_ERR_NONE) {
    Println("failed, code " + String(state));
  }
}
```

**13.4 Ограничения длины текста**
```cpp
const size_t MAX_PAY = 100;

void SendMsg_BR() {
  ...
  String win_buf = utf8_win(serial.buf);
  size_t textLen = min(win_buf.length(), MAX_PAY);
  byte win_array[MAX_PAY+1] = {0};
  win_buf.getBytes(win_array, textLen + 1);
  for (size_t i = 0; i < textLen; i++) new_packet[9 + i] = win_array[i];
  radio.setFrequency(fTX[radio_preset]);
  radio.transmit(new_packet, 9 + textLen);
  ...
}

void SendMsg_AD() {
  ...
  String win_buf = utf8_win(serial.buf);
  size_t textLen = (win_buf.length() > 4) ? min<size_t>(MAX_PAY, win_buf.length() - 4) : 0;
  byte win_array[MAX_PAY+5] = {0};
  win_buf.getBytes(win_array, textLen + 5); // с учетом префикса
  for (size_t i = 0; i < textLen; i++) new_packet[9 + i] = win_array[4 + i];
  radio.setFrequency(fTX[radio_preset]);
  radio.transmit(new_packet, 9 + textLen);
  ...
}
```

**13.5 Ввод — валидация длины** (пример)
```cpp
bool hasArg(size_t n) { return strlen((const char*)serial.buf) > n; }
// перед чтением serial.buf[2] и т.п.: if (!hasArg(2)) { Println("Bad args"); return; }
```

---

## 14) Список функций (по исходнику)
`setup, loop, setFlag, SatPing, SetBW, SetPreset, SetPower, Help, Beacon, Beacon_on, SpreadingFactor, CodingRate, Println, Print, Print_hex, RX_start, received_msg, Auto_tune, SendMsg_BR, SendMsg_AD, utf8_win, win_utf8, eho, Eho_on, info, BoostedGain_on, Find_TX_RX, Find, Online_on, ch_ping, Online, MassPing, all_ping, Frequency_change`.

---

## 15) Итоги
- Протокол и логика корректны и понятны;
- Есть **несколько критичных мелочей**, влияющих на точность (тип `tcxo`), мощность (индексация), стабильность (длины payload), читаемость (`volatile`, enum/struct).
- Внедрение фиксов из §13 + валидации входа сделает систему заметно надежнее без фрагментации архитектуры.

Если нужно — подготовлю **патч‑ветку** с правками и регрессионными тестами на парсинг/сборку пакетов.

